#+OPTIONS: toc:3 h:3
#+OPTIONS: ^:nil
#+PROPERTY: header-args :tangle yes
#+HTML_HEAD: <style>
#+HTML_HEAD:     table { border: 1px solid black; border-collapse:collapse; margin-left: 2%; }
#+HTML_HEAD:     th.org-left   { border: 1px solid black; text-align: left; background-color: lightgray  }
#+HTML_HEAD:     td.org-left   { border: 1px solid black; text-align: left; font-family: monospace; }
#+HTML_HEAD: </style>
#+AUTHOR: Bob Forgey
#+EMAIL: bob@grumpydogconsulting.com
#+TITLE: A _Literate_ and _Fairly Portable_ Emacs Initialization

#+begin_quote
Emacs outshines all other editing software in approximately the same
way that the noonday sun does the stars. It is not just bigger and
brighter; it simply makes everything else vanish.

-- Neal Stephenson, "In the Beginning was the Command Line"
#+end_quote


* Overview
  This is a literate and fairly portable Emacs initialization.

  These configuration files are inspired by Adam Taylor's
  (mailto:mr.adtaylor@gmail.com) initialization code (git clone
  https://github.com/Atman50/emacs-config.git)

** Quick start

   1. Install Emacs version 24 or greater.

   2. clone or checkout this repo (TBD)

   3. Move the resulting directory to =~/.emacs.d= [1]

   4. Launch Emacs

      One of my constraints for this is that the init directory must be
      able to be installed and to be run without Internet access. Some of
      the consequences of this are:

   1. All the packages are contained in the elpa/ directory.

   2. Packages needed for startup (currently, use-package and bind-key)
      are kept as static directories under startup/ and must be manually
      updated occasionally.

** Why a literate configuration
   The documentation is in the same place as the code.

** The importance of the =init.el= file
   There's a detailed explanation on how this configuration works WRT to =init.el= at the end of this document.

   The init.el file is there to tangle this document into the
   configuration to load.

* Implementation

** Emacs first-stage initialization

*** A preamble
    First make sure that we are doing lexical scoping for speed. See
    [[https://nullprogram.com/blog/2016/12/22/][Some Performance Advantages of Lexical Scope blog]].
    #+begin_src emacs-lisp
      ;;; README.el --- a file generated from README.org - do not edit by hand!!!!
      ;; -*- lexical-binding: t; -*-
      ;;; Commentary:
      ;;;     Org tangled from README.org. Edit the org file to chnage this configuration
      ;;; Code:
    #+end_src

*** Speed up loading
    This is a little piece of code that I picked up that might make
    things faster when downloading and installing all the packages.
    This turns down the garbage collector during the use-package
    loading when it has to do some compiling. Set it back when done
    with init.
    #+begin_src emacs-lisp
      (setq gc-cons-threshold 64000000)
      (add-hook 'after-init-hook (lambda () (setq gc-cons-threshold 800000)))
    #+end_src

*** Speed up line movement
    I ran into this little tidbit while reading Sacha Chua's posts
    from Emacs. It is described [[https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746][here]], but to summarize the =next-line=
    defun triggers =line-move-partial= which leads to excessive
    processing. By setting the variable here, the speed of using
    =next-line= gets very cut down.
    #+begin_src emacs-lisp
      (setq auto-window-vscroll nil)
    #+end_src

*** Setup

    This is for values that should be set before anything else.
    #+begin_src emacs-lisp
      (defun ssmm/is-termux-p ()
        (getenv "TERMUX_VERSION")
        )
      
      (setq debug-on-error t)
      ;; UTF-8 as default encoding
      (set-language-environment "UTF-8")
      (add-to-list 'load-path (concat ssmm/cfg-dir "lisp"))
      (cond
       ((ssmm/is-termux-p)
        ;; Don't set font
        )
       ((string-equal system-type "gnu/linux")
        (add-to-list 'default-frame-alist '(font . "-ADBO-Source Code Pro-normal-normal-normal-*-18-*-*-*-m-0-iso10646-1" )))
       ((string-equal system-type "cygwin")
        (set-frame-font "Consolas-14" t t ))
       )
      
      
      (menu-bar-mode -1)
      (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
      (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
      (blink-cursor-mode -1)
      (electric-indent-mode -1)
      (setq backup-inhibited t
            auto-save-default nil
            inhibit-startup-message t
            initial-scratch-message nil
            wdired-allow-to-change-permissions t
            dabbrev-case-distinction nil
            dabbrev-case-fold-search nil
            echo-keystrokes 0.1
            delete-active-region nil
            vc-follow-symlinks t
            disabled-command-function nil
            custom-file (make-temp-file "emacs-custom")
            truncate-lines t
            initial-scratch-message ""
            visible-bell t)
      
      (when (window-system)
        (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
        (when (fboundp 'horizontal-scroll-bar-mode)
          (horizontal-scroll-bar-mode -1))
        (scroll-bar-mode -1))            ;; Scrollbars are waste screen estate
      
      (add-hook 'dired-mode-hook #'toggle-truncate-lines)
      (defalias 'yes-or-no-p 'y-or-n-p)
      ;; straight bootstrap
      ;; (defvar bootstrap-version)
      ;; (let ((bootstrap-file
      ;;        (expand-file-name
      ;;         "straight/repos/straight.el/bootstrap.el"
      ;;         user-emacs-directory))
      ;;       (bootstrap-version 5))
      ;;   (unless (file-exists-p bootstrap-file)
      ;;     (with-current-buffer
      ;;         (url-retrieve-synchronously
      ;;          "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
      ;;          'silent 'inhibit-cookies)
      ;;       (goto-char (point-max))
      ;;       (eval-print-last-sexp)))
      ;;   (load bootstrap-file nil 'nomessage))
      ;; end straight bootstrap
                     ;;; Packages
      (require 'package)
      ;;(require 'package-helper)
      ;; This removes the standard ("gnu" . "https://elpa.gnu.org/packages/")
      
      (setq package-archives (list
                              ;; '("org" . "https://elpa.gnu.org/packages/")
                              '("elpa" . "https://elpa.gnu.org/packages/")
                              '("melpa" . "https://melpa.org/packages/")
                              '("melpa-stable" . "https://stable.melpa.org/packages/")
                              ;;                              '("myemacs" . "~/myemacs")
                              ))
      
      
      ;; (setq package-archives (list
      ;;             '("org" . "https://orgmode.org/elpa/")
      ;;             '("melpa-stable" . "https://stable.melpa.org/packages/")))
      ;; (add-to-list 'package-archives
      ;;              '("myemacs" . "~/myemacs") t)
      
      ;; (add-to-list 'package-archives
      ;;              '("org" . "https://orgmode.org/elpa/") t)
      
                                              ;               '("org" . "http://orgmode.org/elpa/") t)
      ;; (add-to-list 'package-archives
      ;;              '("melpa-stable" . "https://stable.melpa.org/packages/") t)
      
      ;;              ;;'("melpa" . "https://melpa.org/packages/") t)
      ;;              ;;'("melpa" . "https://stable.melpa.org/packages/") t)
      ;; ;; (add-to-list 'package-archives
      ;;              '("marmalade" . "http://marmalade-repo.org/packages/") t)
      (setq package-enable-at-startup nil)
      (setq package-blacklist '(batch-mode))
      (package-initialize)
      
      ;;  (package-refresh-contents)
    #+end_src

    #+RESULTS:

*** Set up straight
    #+begin_src emacs-lisp
      (defvar bootstrap-version)
      (unless (boundp 'straight-use-package)
        (let ((bootstrap-file
               (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
              (bootstrap-version 5))
          (unless (file-exists-p bootstrap-file)
            (with-current-buffer
                (url-retrieve-synchronously
                 "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
                 'silent 'inhibit-cookies)
              (goto-char (point-max))
              (eval-print-last-sexp)))
          (load bootstrap-file nil 'nomessage))
        (straight-use-package 'use-package))
    #+end_src

*** Basics
    This code should be executed before any customization files are loaded.

    - Load path etc.
      #+begin_src emacs-lisp
        ;;(add-to-list 'load-path ssmm/cfg-dir)
        ;; (setq autoload-file (concat ssmm/cfg-dir "loaddefs.el"))
        (setq package-user-dir (concat ssmm/cfg-dir "elpa"))
        ;; (setq custom-file (concat ssmm/cfg-dir "custom.el"))
      #+end_src

    - Compile bare elisp files
      #+begin_src emacs-lisp
        (byte-recompile-directory (concat ssmm/cfg-dir "lisp-early/") 0)
        ;;(byte-recompile-directory "~/.emacs.d/etc/" 0)
      #+end_src

*** Basic packages
    #+begin_src emacs-lisp
      (use-package f)
      (use-package s)
    #+end_src
*** Local emacs package
    #+begin_src emacs-lisp
      ;; (require 'elpa-mirror)
      ;; (setq elpamr-default-output-directory "~/myelpa")
      ;; (add-to-list 'package-archives
      ;;                '("myelpa" . "~/myelpa/"))
    #+end_src
** Universal settings
*** Set variables
    #+begin_src emacs-lisp
      (eval-and-compile
        (setq use-package-verbose t
              use-package-always-ensure t
              use-package-expand-minimally nil
              use-package-compute-statistics t))
      ;; debug-on-error t)
      (defvar ssmm/true-home (file-truename "~/"))
    #+end_src

*** Align your code in a pretty way.
    #+begin_src emacs-lisp
      (global-set-key (kbd "C-x \\") 'align-regexp)
    #+end_src

*** Completion that uses many different methods to find options.
    #+begin_src emacs-lisp
      (global-set-key (kbd "M-/") 'hippie-expand)
    #+end_src

*** Use regex searches by default.
    #+begin_src emacs-lisp
      (setq isearch-lazy-count t)
      (global-set-key (kbd "C-s") 'isearch-forward-regexp)
      (global-set-key (kbd "\C-r") 'isearch-backward-regexp)
      (global-set-key (kbd "C-M-s") 'isearch-forward)
      (global-set-key (kbd "C-M-r") 'isearch-backward)
    #+end_src

*** Window switching. (C-x o goes to the next window)
    #+begin_src emacs-lisp
      ;; eh, I don't use it (windmove-default-keybindings) ;; Shift+direction
      (global-set-key (kbd "C-x O") (lambda () (interactive) (other-window -1))) ;; back one
      (global-set-key (kbd "C-x C-o") (lambda () (interactive) (other-window 2))) ;; forward two
    #+end_src

*** Help should search more than just commands
    #+begin_src emacs-lisp
      (global-set-key (kbd "C-h a") 'apropos)
    #+end_src
*** Disable mouse
    #+begin_src emacs-lisp
      (unless (ssmm/is-termux-p)
        (use-package disable-mouse
          :config
          (global-disable-mouse-mode)
          )
        )
    #+end_src

** UI settings
*** Terminal setup
    For working in xterm: XTERM=xterm-256color

    #+begin_src emacs-lisp
      (defadvice terminal-init-xterm (after select-shift-up activate)
        (define-key input-decode-map "\e[1;2A" [S-up])
        (define-key input-decode-map "\e[1;2B" [S-down])
        (define-key input-decode-map "\e[1;2C" [S-right])
        (define-key input-decode-map "\e[1;2D" [S-left])
        (define-key input-decode-map "\e[1;5A" [C-up])
        (define-key input-decode-map "\e[1;5B" [C-down])
        (define-key input-decode-map "\e[1;5C" [C-right])
        (define-key input-decode-map "\e[1;5D" [C-left])
        (define-key input-decode-map "\e[1;3A" [M-up])
        (define-key input-decode-map "\e[1;3B" [M-down])
      
        (define-key input-decode-map "\e[1;3C" [M-right])
        (define-key input-decode-map "\e[1;3D" [M-left])
        )
    #+end_src

*** Free up C-m for use as prefix map
    From https://emacs.stackexchange.com/questions/20240/how-to-distinguish-c-m-from-return
    To distinguish C-m from RET in a GUI Emacs, one could change C-i to C-m in @nispio's answer:
    #+begin_src emacs-lisp
      ;;(define-key input-decode-map [?\r] 'newline)
      (define-key input-decode-map [?\r] [?\C-j])
      ;; (define-key input-decode-map [?\C-m] [C-m])
    #+end_src
*** UI setup

    #+begin_src emacs-lisp
      (use-package zenburn-theme
        :config
        (load-theme 'zenburn t)
        )
      
      ;; (with-package* smart-mode-line
      ;;   (setq sml/apply-theme 'dark)
      ;;   (setq sml/shorten-directory t)
      ;;   (setq sml/shorten-modes t)
      ;;   (setq sml/name-width 40)
      ;;   (setq sml/mode-width 'full)
      ;;   ;;(add-hook 'after-init-hook 'sml/setup nil)
      ;;   (add-hook 'after-init-hook (lambda () (message "Goodbye from init-hook")) t)
      ;;   )
      
      ;; Go backwards through windows
      (global-set-key (kbd "C-x p") (lambda () (interactive) (other-window -1)))
      
      ;; C-x C-c is bad bad bad
      (global-unset-key (kbd "C-x C-c"))
      (global-set-key (kbd "C-x C-c C-c") 'save-buffers-kill-terminal)
      (setq tab-width 3)
    #+end_src

** defuns
   # *** refresh packages from network
   # Currently using https://github.com/redguardtoo/elpa-mirror, for speed,
   # compatibility between emacs versions/architectures, and stability.
   # However, we need some way to update from the internet.

   # After this command, you should probably run M-x
   # elpamr-create-mirror-for-installed again, to update ~/myemacs.
   # #+begin_src emacs-lisp
   #      (defun ssmm-update-packages-from-internet()
   #      "Runs package-list-packages with extra repos.
   #      "
   #      (interactive)
   #      ;;(let ((package-archives package-archives))
   #         (add-to-list 'package-archives
   #                      '("org" . "https://elpa.gnu.org/packages/"))
   #         (add-to-list 'package-archives
   #                      '("melpa" . "https://stable.melpa.org/packages/"))
   #         (package-list-packages)
   #        ;;)
   #   )
   # #+end_src

   # #+RESULTS:
   # : ssmm-update-packages-from-internet

*** make-repeatable-command
    From emacs prelude-core.
    #+begin_src emacs-lisp
      
      (require 'repeat)
      
      (defun make-repeatable-command (cmd)
        "Returns a new command that is a repeatable version of CMD.
      The new command is named CMD-repeat.  CMD should be a quoted
      command.
      
      This allows you to bind the command to a compound keystroke and
      repeat it with just the final key.  For example:
      
        (global-set-key (kbd \"C-c a\") (make-repeatable-command 'foo))
      
      will create a new command called foo-repeat.  Typing C-c a will
      just invoke foo.  Typing C-c a a a will invoke foo three times,
      and so on."
        (fset (intern (concat (symbol-name cmd) "-repeat"))
              `(lambda ,(help-function-arglist cmd) ;; arg list
                 ,(format "A repeatable version of `%s'." (symbol-name cmd)) ;; doc string
                 ,(interactive-form cmd) ;; interactive form
                 ;; see also repeat-message-function
                 (setq last-repeatable-command ',cmd)
                 (repeat nil)))
        (intern (concat (symbol-name cmd) "-repeat")))
      
    #+end_src

*** ssmm/goto-file-line-other-window
    Given a string in a buffer that looks like "filename:linenumber", go there.

    #+begin_src emacs-lisp
      (defun ssmm/goto-file-line-other-window ()
        "Given a string in a buffer that looks like 'filename:linenumber', go there."
        (interactive)
        (beginning-of-thing 'filename)
        (and (looking-at "\\([-a-zA-Z._0-9/]+\\):\\([0-9]+\\)")
             (let ((filename (match-string 1))
                   (line_num (string-to-number (match-string 2))))
               (find-file-other-window filename)
               (goto-line line_num)
               )))
      
      (global-set-key (kbd "C-<kp-home>") 'ssmm/goto-file-line-other-window)
      
    #+end_src

*** Copy characters from previous line
    From emacswiki

    #+begin_src emacs-lisp
      (autoload 'copy-from-above-command "misc"
        "Copy characters from previous nonblank line, starting just above point.
      
        \(fn &optional arg)"
        'interactive)
      
      (global-set-key [f6] (lambda ()
                             (interactive)
                             (copy-from-above-command 1)))
    #+end_src

*** Default buffer

    #+begin_src emacs-lisp
      ;;(setq ssmm-default-buffer "iff_config.c")
      (defun ssmm-goto-default-buffer ()
        (interactive)
        (switch-to-buffer ssmm-default-buffer))
      (global-set-key (kbd "C-'") 'ssmm-goto-default-buffer)
    #+end_src

*** Working with multiple screens

    #+begin_src emacs-lisp
      (defun ssmm-setup-frames ()
        (interactive)
        ;;(make-frame-on-display ":0.1")
        (make-frame)
                                              ;(make-frame-on-display "rforgey-windows:0.0")
                                              ;(make-frame-on-display "rforgey-windows:0.1")
        )
      ;;(defun ssmm-a-setup-frames ()
      ;; (interactive)
      ;; (pop-to-buffer "*scratch*")
      ;; (delete-other-windows)
      ;; (setq frame0 (selected-frame))
      ;; (make-frame-on-display ":0.1")
      ;; (pop-to-buffer "*scratch*")
      ;; (setq frame1 (selected-frame))
      ;; (frame-configuration-to-register ?0)
      ;; (frame-configuration-to-register ?1)
      ;; (frame-configuration-to-register ?2)
      ;; (frame-configuration-to-register ?3)
      ;; (frame-configuration-to-register ?4)
      ;; (frame-configuration-to-register ?5)
      ;; )
      
    #+end_src

*** XML
    Defuns to work with XML files, as some operations in nXML mode cause
    Emacs to spin at 100% CPU.
    #+begin_src emacs-lisp
      (defun ssmm-comment-xml-item ()
        "Puts a comment around an XML tag, and fixes double-hyphens."
        (interactive)
        (search-backward "<")
        (er/expand-region 1)
        (replace-string "--" "- -" nil (region-beginning) (region-end))
        (search-backward "<")
        (er/expand-region 1)
        (kill-region (region-beginning) (region-end))
        (insert-string "<!-- ")
        (yank)
        (insert-string " -->")
        )
    #+end_src
*** CamelCase

    #+begin_src emacs-lisp
      ;; These three defuns started out from http://www.emacswiki.org/CamelCase
      (defun mapcar-head (fn-head fn-rest list)
        "Like MAPCAR, but applies a different function to the first element."
        (if list
            (cons (funcall fn-head (car list)) (mapcar fn-rest (cdr list)))))
      
      (defun camelize (s)
        "Convert string S (with spaces or _) to CamelCase string."
        (mapconcat 'identity (mapcar
                              '(lambda (word) (capitalize (downcase word)))
                              (split-string s "[ _]+")) ""))
      
      (defun camelize-method (s)
        "Convert string S (with spaces or _) to camelCase string."
        (mapconcat 'identity (mapcar-head
                              '(lambda (word) (downcase word))
                              '(lambda (word) (capitalize (downcase word)))
                              (split-string s "[ _]+")) ""))
      
      (defun camelCase (start end)
        "Coverts region to camelCase."
        (interactive "r")
        (let* ((str (buffer-substring-no-properties start end))
               (ccstr (camelize-method str))
               )
          (delete-region start end)
          (insert ccstr)
          )
        )
      
      (defun CamelCase (start end)
        "Coverts region to CamelCase."
        (interactive "r")
        (let* ((str (buffer-substring-no-properties start end))
               (ccstr (camelize str))
               )
          (delete-region start end)
          (insert ccstr)
          )
        )
      
      ;; From http://stackoverflow.com/questions/9288181/converting-from-camel-case-to-in-emacs
      (defun un-camelcase (start end)
        "Converts CamelCase region to underscores."
        (interactive "r")
        (replace-regexp "\\([A-Z]\\)" "_\\1" nil start end)
        (downcase-region start end)
        )
      
      (defun un-camelcase-word-at-point ()
        "un-camelcase word at point."
        (interactive)
        (save-excursion
          (let ((bounds (bounds-of-thing-at-point 'word)))
            (replace-regexp "\\([A-Z]\\)" "_\\1" nil (1+ (car bounds)) (cdr bounds))
            (downcase-region (car bounds) (cdr bounds))
            )
          )
        )
    #+end_src

*** Center rectangle
    #+begin_src emacs-lisp
      ;;; from http://stackoverflow.com/questions/11651604/how-to-center-text-in-emacs
      ;;; 'select your interesting rectangle and run':
      (defun center-rectangle (beg end)
        (interactive "*r")
        (kill-rectangle beg end)
        (with-temp-buffer
          (yank-rectangle)
          (setq fill-column (current-column))
          (center-region (point-min) (point-max))
          (goto-char (point-max))
          (move-to-column fill-column t)
          (kill-rectangle (point-min) (point-max)))
        (goto-char beg)
        (yank-rectangle))
    #+end_src

*** C++ defuns
    Find the name of the next member function in a C++ source file.
    Used in yasnippet 'fblock'
    #+begin_src emacs-lisp
      (defun ssmm-which-member-function ()
        (interactive)
        (save-excursion
          (re-search-forward "::\\([^()]+\\)")
          )
        (match-string 1)
        )
    #+end_src
*** Python
**** Mark a word to refactor to self.word
     You will probably want to be in the superword minor mode for this.
     #+begin_src emacs-lisp
       (defun ssmm-refactor-to-member ()
         "With point somewhere in a word, start a replace to self.word"
         (interactive)
         (let ((foo))
           (subword-right)
           (subword-left)
           (subword-mark 1)
           (setq foo (buffer-substring-no-properties (region-beginning) (region-end)))
           (query-replace-regexp (concat "\\b" foo "\\b") (concat "self." foo))
           ))
       
     #+end_src
** Registers
   Registers allow you to jump to a file or other location quickly. Use
   =C-x r j= followed by the letter of the register (i for =init.el=, r
   for this file) to jump to it.

   You should add registers here for the files you edit most often.

   #+begin_src emacs-lisp :results silent
     (dolist
         (r `((?i (file . ,(concat ssmm/cfg-dir "init.el")))
              (?I (file . ,(let* ((user user-login-name)
                                  (org (expand-file-name (concat user ".org") ssmm/cfg-dir))
                                  (el  (expand-file-name (concat user ".el") ssmm/cfg-dir))
                                  (dir (expand-file-name user ssmm/cfg-dir)))
                             (cond
                              ((file-exists-p org) org)
                              ((file-exists-p el)  el)
                              (t dir)))))
              (?s (file . ,(concat ssmm/cfg-dir "config.org")))
              ))
       (set-register (car r) (cadr r)))
   #+end_src
** Miscellaneous

*** Transparently open compressed files
    #+begin_src emacs-lisp
      (auto-compression-mode t)
    #+end_src

*** Save a list of recent files visited.
    #+begin_src emacs-lisp
    (recentf-mode 0)
    #+end_src emacs-lisp

*** Highlight matching parentheses when the point is on them.
    #+begin_src emacs-lisp
      (show-paren-mode 1)
    #+end_src

*** Other, spell checking, tabs, imenu and a coding hook
    #+begin_src emacs-lisp
      (set-default 'indent-tabs-mode nil)
      (set-default 'indicate-empty-lines t)
      (set-default 'imenu-auto-rescan t)
      
      (add-hook 'text-mode-hook 'turn-on-auto-fill)
      (add-hook 'text-mode-hook 'turn-on-flyspell)
      
      (defvar starter-kit-coding-hook nil
        "Hook that gets run on activation of any programming mode.")
      
      (defalias 'yes-or-no-p 'y-or-n-p)
      ;; Seed the random-number generator
      (random t)
    #+end_src

*** Don't clutter up directories with files~
    Rather than saving backup files scattered all over the file system,
    let them live in the =backups/= directory inside of the starter kit.
    Nope; put them in /tmp... Use 'em or lose 'em. If it's important, use
    git.
    #+begin_src emacs-lisp
      (setq backup-directory-alist `(("/tmp")))
    #+end_src

** Keymaps

   #+begin_src emacs-lisp
     ;;(define-key input-decode-map [?\C-m] [C-m])
     
     (eval-and-compile
       (mapc #'(lambda (entry)
                 (define-prefix-command (cdr entry))
                 (bind-key (car entry) (cdr entry)))
             '(("C-,"   . my-ctrl-comma-map)
               ("<C-m>" . my-ctrl-m-map)
     
               ("C-h e" . my-ctrl-h-e-map)
               ("C-h x" . my-ctrl-h-x-map)
     
               ("C-c b" . my-ctrl-c-b-map)
               ("C-c e" . my-ctrl-c-e-map)
               ("C-c m" . my-ctrl-c-m-map)
               ("C-c w" . my-ctrl-c-w-map)
               ("C-c y" . my-ctrl-c-y-map)
               ("C-c H" . my-ctrl-c-H-map)
               ("C-c N" . my-ctrl-c-N-map)
               ("C-c (" . my-ctrl-c-open-paren-map)
               ("C-c -" . my-ctrl-c-minus-map)
               ("C-c =" . my-ctrl-c-equals-map)
               ("C-c ." . my-ctrl-c-r-map)
               )))
   #+end_src

** Packages
*** Avy
    #+begin_src emacs-lisp
      (use-package avy
        :bind* ("C-." . avy-goto-char-timer)
        :config
        (avy-setup-default))
      
    #+end_src
*** EMMS
    #+begin_src emacs-lisp
      (use-package emms
        :config
        (emms-all)
        (emms-default-players))
    #+end_src
*** Multiple Cursors
    #+begin_src emacs-lisp
      (use-package mc-extras
        :after multiple-cursors
        :bind (("<C-m> M-C-f" . mc/mark-next-sexps)
               ("<C-m> M-C-b" . mc/mark-previous-sexps)
               ("<C-m> <"     . mc/mark-all-above)
               ("<C-m> >"     . mc/mark-all-below)
               ("<C-m> C-d"   . mc/remove-current-cursor)
               ("<C-m> C-k"   . mc/remove-cursors-at-eol)
               ("<C-m> M-d"   . mc/remove-duplicated-cursors)
               ("<C-m> |"     . mc/move-to-column)
               ("<C-m> ~"     . mc/compare-chars)))
      
      ;; (use-package mc-freeze
      ;;   :after multiple-cursors
      ;;   :bind ("<C-m> f" . mc/freeze-fake-cursors-dwim))
      
      ;; (use-package mc-rect
      ;;   :after multiple-cursors
      ;;   :bind ("<C-m> ]" . mc/rect-rectangle-to-multiple-cursors))
      
      (use-package multiple-cursors
        :after phi-search
        :defer 1
      
        ;; - Sometimes you end up with cursors outside of your view. You can scroll
        ;;   the screen to center on each cursor with `C-v` and `M-v`.
        ;;
        ;; - If you get out of multiple-cursors-mode and yank - it will yank only
        ;;   from the kill-ring of main cursor. To yank from the kill-rings of every
        ;;   cursor use yank-rectangle, normally found at C-x r y.
      
        :bind (("<C-m> ^"     . mc/edit-beginnings-of-lines)
               ("<C-m> `"     . mc/edit-beginnings-of-lines)
               ("<C-m> $"     . mc/edit-ends-of-lines)
               ("<C-m> '"     . mc/edit-ends-of-lines)
               ("<C-m> R"     . mc/reverse-regions)
               ("<C-m> S"     . mc/sort-regions)
               ("<C-m> +"     . mc/mark-next-like-this)
               ("<C-m> -"     . mc/mark-previous-like-this)
               ("<C-m> W"     . mc/mark-all-words-like-this)
               ("<C-m> Y"     . mc/mark-all-symbols-like-this)
               ("<C-m> a"     . mc/mark-all-like-this-dwim)
               ("<C-m> c"     . mc/mark-all-dwim)
               ("<C-m> l"     . mc/insert-letters)
               ("<C-m> n"     . mc/insert-numbers)
               ("<C-m> r"     . mc/mark-all-in-region)
               ("<C-m> s"     . set-rectangular-region-anchor)
               ("<C-m> %"     . mc/mark-all-in-region-regexp)
               ("<C-m> t"     . mc/mark-sgml-tag-pair)
               ("<C-m> w"     . mc/mark-next-like-this-word)
               ("<C-m> x"     . mc/mark-more-like-this-extended)
               ("<C-m> y"     . mc/mark-next-like-this-symbol)
               ("<C-m> C-x"   . reactivate-mark)
               ("<C-m> C-SPC" . mc/mark-pop)
               ("<C-m> ("     . mc/mark-all-symbols-like-this-in-defun)
               ("<C-m> C-("   . mc/mark-all-words-like-this-in-defun)
               ("<C-m> M-("   . mc/mark-all-like-this-in-defun)
               ("<C-m> ["     . mc/vertical-align-with-space)
               ("<C-m> {"     . mc/vertical-align)
      
               ("S-<down-mouse-1>")
               ("S-<mouse-1>" . mc/add-cursor-on-click))
      
        :bind (:map selected-keymap
                    ("c"   . mc/edit-lines)
                    ("."   . mc/mark-next-like-this)
                    ("<"   . mc/unmark-next-like-this)
                    ("C->" . mc/skip-to-next-like-this)
                    (","   . mc/mark-previous-like-this)
                    (">"   . mc/unmark-previous-like-this)
                    ("C-<" . mc/skip-to-previous-like-this)
                    ("y"   . mc/mark-next-symbol-like-this)
                    ("Y"   . mc/mark-previous-symbol-like-this)
                    ("w"   . mc/mark-next-word-like-this)
                    ("W"   . mc/mark-previous-word-like-this))
      
        :preface
        (defun reactivate-mark ()
          (interactive)
          (activate-mark)))
      
      (use-package phi-search
        :defer 1)
      
      (use-package phi-search-mc
        :after (phi-search multiple-cursors)
        :config
        (phi-search-mc/setup-keys)
        (add-hook 'isearch-mode-mode #'phi-search-from-isearch-mc/setup-keys))
    #+end_src

    #+begin_src emacs-lisp
      (use-package selected
        :demand t
        :bind (:map selected-keymap
                    ("[" . align-code)
                    ("f" . fill-region)
                    ("U" . unfill-region)
                    ("d" . downcase-region)
                    ("u" . upcase-region)
                    ("r" . reverse-region)
                    ("s" . sort-lines))
        :config
        (selected-global-mode 1))
    #+end_src

    # *** Elpa-mirror
    # #+begin_src emacs-lisp
    #   (use-package elpa-mirror
    #   )
    # #+end_src

*** Pinboard api
    #+begin_src emacs-lisp
      (use-package pinboard-api
        )
      (use-package queue
        )
    #+end_src

** Hydra
   #+begin_src emacs-lisp
     (use-package hydra
       :defer t
       :config
       (defhydra hydra-zoom (global-map "<f2>")
         "zoom"
         ("g" text-scale-increase "in")
         ("l" text-scale-decrease "out")))
     
     
   #+end_src
** Org mode
   #+begin_src emacs-lisp
     (assq-delete-all 'org package--builtins)
     (use-package org
       ;; :ensure org-plus-contrib
       :demand
       :config
       (load-library "org")
       (load-library "org-contacts")
       (load-library "org-macs")
       (load-library "org-src")
       (load-library "org-compat")
       ;; (require 'org-contacts)
       ;; (require 'org-macs)
       ;; (require 'org-src)
       :bind (:map org-mode-map
                   (("S-C-M-u" . org-timestamp-up)
                    ("S-C-M-d" . org-timestamp-down))
                   )
       )
     
     ;;  (load-library "org")
     ;;  (load-library "org-contacts")
     ;;  (load-library "org-macs")
     ;;  (load-library "org-src")
     ;;
     ;; A default name to give context to some of the elisp farther down.
     ;; It generally gets changed in a system or user file.
     (if (ssmm/is-termux-p)
         (setq ssmm-orgfiles-dir (concat ssmm/true-home "storage/shared/Documents/org/"))
       (setq ssmm-orgfiles-dir (concat ssmm/true-home "org/"))
       )
     (defvar ssmm-org-main-file (concat ssmm-orgfiles-dir "organizer.org") "Path to main org-mode file")
     (defvar ssmm-org-clippings-file (concat ssmm-orgfiles-dir "clippings.org") "Path to clippings org-mode file")
     (defvar ssmm-org-contacts-file (concat ssmm-orgfiles-dir "contacts.org") "Path to contacts org-mode file")
     (setq org-contacts-files (list ssmm-org-contacts-file))
     
     (defvar ssmm-org-main-buffer (file-name-nondirectory ssmm-org-main-file) "Buffer name for main org-mode file")
     (defvar ssmm-org-roam-dir (concat ssmm-orgfiles-dir "roam/"))
     (defvar ssmm-org-inbox-file (concat ssmm-org-roam-dir "inbox.org") "Path to GTD org-mode file")
     (setq org-agenda-files nil)
     (setq org-src-preserve-indentation nil
           org-edit-src-content-indentation 2)
     (setq org-id-locations-file (expand-file-name ".org-id-locations" ssmm-orgfiles-dir))
     
     (setq org-todo-keywords
           '((sequence "INBOX(i)"
                       "TODO(t)"
                       "STARTED(s)"
                       "WAITING(w)"
                       "APPT(a)"
                       "|"
                       "DONE(d)"
                       "CANCELLED(c)"
                       "DEFERRED(D)"
                       )))
   #+end_src

   Configuration for the eminently useful [[http://orgmode.org/][Org Mode]].

   Org-mode is for keeping notes, maintaining ToDo lists, doing project
   planning, and authoring with a fast and effective plain-text system.
   Org Mode can be used as a very simple folding outliner or as a complex
   GTD system or tool for reproducible research and literate programming.

   For more information on org-mode check out [[http://orgmode.org/worg/][worg]], a large Org-mode wiki
   which is also *implemented using* Org-mode and [[http://git-scm.com/][git]].

   #+begin_src emacs-lisp
     ;;   (use-package org
     ;;     :ensure org-plus-contrib
     ;;     :demand
     ;;     )
     ;; (require 'org)
   #+end_src
   The [[http://orgmode.org/manual/Agenda-Views.html#Agenda-Views][Org-mode agenda]] is good to have close at hand
   #+begin_src emacs-lisp
     (define-key global-map "\C-ca" 'org-agenda)
   #+end_src

   Org-mode supports [[http://orgmode.org/manual/Hyperlinks.html#Hyperlinks][links]], this command allows you to store links
   globally for later insertion into an Org-mode buffer.  See
   [[http://orgmode.org/manual/Handling-links.html#Handling-links][Handling-links]] in the Org-mode manual.
   #+begin_src emacs-lisp
     (define-key global-map "\C-cl" 'org-store-link)
   #+end_src

   For convenience, inside code blocks indent according to the block mode:
   #+begin_src emacs-lisp
     (setq org-src-tab-acts-natively t)
   #+end_src

   Org-superstar, for pretty
   #+begin_src emacs-lisp
     (when (eq (window-system) 'x)
       (use-package org-superstar
         :hook (org-mode . org-superstar-mode)))
   #+end_src
*** Note taking
    org-roam and capture stuff taken largely from https://renatgalimov.github.io/org-basb-code/

    # someday - #+INCLUDE: "~/.emacs.d/basb.org"
    Looks like I'll have to make an org file that exports included org
    files to another org file. See
    https://dev.to/jfhbrook/multi-file-org-babel-tangles-with-include-directives-5522

    From the org-roam Ecosystem: https://org-roam.readthedocs.io/en/develop/ecosystem
    org-roam and capture stuff taken largely from https://renatgalimov.github.io/org-basb-code/

**** org-roam
     #+begin_src emacs-lisp
       ;;       (add-to-list 'load-path "~/Projects/readonly-repos/org-roam")
       (when (ssmm/is-termux-p)
         (use-package emacsql-sqlite3
           :straight (:host github :repo "cireu/emacsql-sqlite3")
           )
         )
     #+end_src
     #+begin_src emacs-lisp
       (defun ssmm/days-back-to-last-friday ()
         (let ((num 1)
               (potfri))
           (while (progn
                    (setq potfri (decode-time (- (float-time) (* 3600.0 24.0 num))))
                    (setq num (+ num 1))
                    (not (eq (elt potfri 6) 5))
                    ))
           (- num 1)
           )
         )
       
       (defun ssmm/days-forward-to-next-monday ()
         (let ((num 0)
               (potmon))
           (while (progn
                    (setq potmon (decode-time (+ (float-time) (* 3600.0 24.0 num))))
                    (setq num (+ num 1))
                    (not (eq (elt potmon 6) 1))
                    ))
           (- num 1)
           )
         )
       
       (defun ssmm/org-roam-dailies-goto-last-friday ()
         (interactive)
         (org-roam-dailies-goto-yesterday (ssmm/days-back-to-last-friday))
         )
       
       (defun ssmm/org-roam-dailies-capture-next-monday ()
         (interactive)
         (org-roam-dailies-capture-tomorrow (ssmm/days-forward-to-next-monday))
         )
       
       (setq org-roam-v2-ack t)                ;
       (use-package org-roam                   ;
         ;; :straight (:local-repo "/home/bob/Projects/readonly-repos/org-roam"
         ;;     :files (:defaults "extensions/*")
         ;;     :build (:not compile))
         :after org
         :config
         (require 'org-roam-dailies) ;; ensure keymap is available
         (setq org-roam-v2-ack t)
         (setq org-roam-directory ssmm-org-roam-dir)
         (setq org-roam-file-extensions '("org"))
         (setq org-roam-db-location (expand-file-name "org-roam.db" ssmm-org-roam-dir))
         (when (ssmm/is-termux-p)
           (setq org-roam-database-connector 'sqlite3)
           )
         ;;(org-roam-setup)
       
         (setq org-roam-capture-templates
               '(
                 ("d" "default" plain "%?"
                  :if-new
                  (file+head "%<%Y%m%d%H%M%S>.org" "#+title: ${title}\n")
                  ;; (file+head "${slug}.org"
                  ;;            "#+title: ${title}\n")
                  :immediate-finish t
                  :jump-to-captured t
                  :unnarrowed t)
                 ("l" "literature" plain "%?"
                  :if-new
                  (file+head "%<%Y%m%d%H%M%S>.org"
                             "#+title: ${title}\n#+filetags: literature\nSource:"
                             )
                  ;; (file+head "${slug}.org"
                  ;;            "#+title: ${title}\n")
                  :immediate-finish t
                  :jump-to-captured t
                  :unnarrowed t)
                 ("p" "project" plain "%?"
                  :if-new
                  (file+head "%<%Y%m%d%H%M%S>.org"
                             "#+title: ${title}\n#+filetags: project\n"
                             )
                  :immediate-finish t
                  :jump-to-captured t
                  :unnarrowed t)
                 ("e" "email" plain "%?"
                  :target (file+head "email/%(string-replace \".txt\" \"\" \"%f\").org"
                                     "#+title: %(string-replace \".txt\" \"\" \"%f\")\n%i")
                  :empty-lines-before 1
                  :jump-to-captured t
                  :unnarrowed t)
                 ("a" "area" plain "%?"
                  :if-new
                  (file+head "%<%Y%m%d%H%M%S>.org"
                             "#+title: ${title}\n#+filetags: area\n\n"
                             )
                  :immediate-finish t
                  :jump-to-captured t
                  :unnarrowed t)
                 ("L" "Library" plain "%?"
                  :if-new
                  (file+head "%<%Y%m%d%H%M%S>.org"
                             "#+title: ${title}\n#+filetags: library\n\n"
                             )
                  :immediate-finish t
                  :jump-to-captured t
                  :unnarrowed t)
                 ("w" "org-import-capture" plain "%?"
                  :target (file+head "library/${slug}.org"
                                     "#+title: ${title}\n")
                  :jump-to-captured t
                  :unnarrowed t)
                 ;; Example of how to add template
                 ;;  ("G" "Guff" plain "%?"
                 ;; :if-new
                 ;; (file+head "${slug}.org"
                 ;;            "#+title: ${title}\n")
                 ;; :immediate-finish t
                 ;; :jump-to-captured t
                 ;; :unnarrowed t)
                 ))
         (setq org-roam-dailies-capture-templates
               '(
                 ("D" "default" plain
                  "* Tasks\n\n* Happenings\n%?"
                  :target (file+head "%<%Y-%m-%d>.org"
                                     "#+title: %<%Y-%m-%d>\n"))
                 ))
         (org-roam-db-autosync-mode)
         :bind (
                ;; :map org-roam-mode-map
                ("C-c n /" . org-roam-node-find)
                ("C-c n c" . org-roam-capture)
                ("C-c n i" . org-roam-node-insert)
                ("C-c n r" . org-roam-buffer-toggle)
                :map org-roam-mode-map
                (("S-C-M-u" . org-timestamp-up)
                 ("S-C-M-d" . org-timestamp-down)
                 )
                :map org-roam-dailies-map
                ("F" . org-roam-dailies-goto-last-friday)
                ("M" . org-roam-dailies-capture-next-monday)
                )
         :bind-keymap
         ("C-c n d" . org-roam-dailies-map)
         )
       
       ;; (require 'org-roam-emacs)
       ;; (("C-c n l" . org-roam)
       ;;  ("C-c n f" . org-roam-find-file)
       ;;  ("C-c n b" . org-roam-switch-to-buffer)
       ;;  ("C-c n g" . org-roam-show-graph))
       
       ;; (load-library "org-roam")
       ;; I have trouble with Ripgrep on Windows
       ;; Commit 0163461f adds default user option for
       ;; sections. You no longer need to set the variable explicitly
       ;; (setq org-roam-mode-sections
       ;;      (list #'org-roam-backlinks-insert-section
       ;;            #'org-roam-reflinks-insert-section))
       ;;#'org-roam-unlinked-references-insert-section))
       
     #+end_src
     #+begin_src emacs-lisp
                                               ;       (use-package org-roam                   ;
                                               ;             :hook
                                               ;             (after-init . org-roam-mode)
                                               ;             (make-directory ssmm-org-roam-dir t)
                                               ;             ;;:straight (:host github :repo "jethrokuan/org-roam" :branch "develop")
                                               ;             :custom
                                               ;             (org-id-link-to-org-use-id t)
                                               ;             (org-roam-directory ssmm-org-roam-dir)
                                               ;             :bind (:map org-roam-mode-map
                                               ;                     (("C-c n l" . org-roam)
                                               ;                      ("C-c n f" . org-roam-find-file)
                                               ;                      ("C-c n b" . org-roam-switch-to-buffer)
                                               ;                      ("C-c n g" . org-roam-show-graph))
                                               ;                     :map org-mode-map
                                               ;                     (("C-c n i" . org-roam-insert))))
       
     #+end_src
     #+begin_src emacs-lisp
       (require 'org-roam-protocol)            ;
       ;; Below is the default
       ;;   (setq org-roam-capture-ref-templates
       ;;         '(("r" "ref" plain (function org-roam-capture--get-point)
       ;;            "%?"
       ;;            :file-name "websites/${slug}"
       ;;            :head "#+TITLE: ${title}
       ;; #+ROAM_KEY: ${ref}
       ;; - source :: ${ref}"
       ;;            :unnarrowed t)))
       ;;   (setq org-roam-capture-ref-templates
       ;;         '(("r" "ref" plain (function org-roam-capture--get-point)
       ;;            "%?"
       ;;            :file-name "websites/${slug}"
       ;;            :head "#+TITLE: ${title}
       ;; #+ROAM_KEY: ${ref}
       ;; - source :: ${ref}"
       ;;            :unnarrowed t)))
     #+end_src
     roam-extra:
     https://magnus.therning.org/2021-07-23-keeping-todo-items-in-org-roam-v2.html

     #+begin_src emacs-lisp
       (defun roam-extra:get-filetags ()
         (split-string (or (org-roam-get-keyword "filetags") "")))
       
       (defun roam-extra:add-filetag (tag)
         (let* ((new-tags (cons tag (roam-extra:get-filetags)))
                (new-tags-str (combine-and-quote-strings new-tags)))
           (org-roam-set-keyword "filetags" new-tags-str)))
       
       (defun roam-extra:del-filetag (tag)
         (let* ((new-tags (seq-difference (roam-extra:get-filetags) `(,tag)))
                (new-tags-str (combine-and-quote-strings new-tags)))
           (org-roam-set-keyword "filetags" new-tags-str)))
       
       
       
       (defun roam-extra:todo-p ()
         "Return non-nil if current buffer has any TODO entry.
       
              TODO entries marked as done are ignored, meaning the this
              function returns nil if current buffer contains only completed
              tasks."
         (org-element-map
             (org-element-parse-buffer 'headline)
             'headline
           (lambda (h)
             (eq (org-element-property :todo-type h)
                 'todo))
           nil 'first-match))
       
       (defun roam-extra:update-todo-tag ()
         "Update TODO tag in the current buffer."
         (when (and (not (active-minibuffer-window))
                    (org-roam-file-p))
           (org-with-point-at 1
             (let* ((tags (roam-extra:get-filetags))
                    (is-todo (roam-extra:todo-p)))
               (cond ((and is-todo (not (seq-contains-p tags "todo")))
                      (roam-extra:add-filetag "todo"))
                     ((and (not is-todo) (seq-contains-p tags "todo"))
                      (roam-extra:del-filetag "todo")))))))
       
       (defun roam-extra:todo-files ()
         "Return a list of roam files containing todo tag."
         (org-roam-db-sync)
         (let ((todo-nodes (seq-filter (lambda (n)
                                         (seq-contains-p (org-roam-node-tags n) "todo"))
                                       (org-roam-node-list))))
           (seq-uniq (seq-map #'org-roam-node-file todo-nodes))))
       
       (defun roam-extra:update-todo-files (&rest _)
         "Update the value of `org-agenda-files'."
         (setq org-agenda-files (roam-extra:todo-files)))
       
       (add-hook 'find-file-hook #'roam-extra:update-todo-tag)
       (add-hook 'before-save-hook #'roam-extra:update-todo-tag)
       (advice-add 'org-agenda :before #'roam-extra:update-todo-files)
     #+end_src
     Vulpea: [[https://github.com/d12frosted/vulpea]]
     #+begin_src emacs-lisp
       (use-package vulpea
         :ensure t
         :commands vulpea-buffer-prop-get
         ;; hook into org-roam-db-autosync-mode you wish to enable
         ;; persistence of meta values (see respective section in README to
         ;; find out what meta means)
         :hook ((org-roam-db-autosync-mode . vulpea-db-autosync-enable)))
     #+end_src

**** Capture documents

     Capture targets:
     E-books
     Documents
     Videos
     Audios
     Images

     To capture we use Pandoc and org-pandoc-import

     #+begin_src emacs-lisp
       (use-package org-pandoc-import
         :straight (:host github
                          :repo "tecosaur/org-pandoc-import"
                          :files ("*.el" "filters" "preprocessors"))
       
         :bind (("C-c n o" . org-pandoc-import-as-org)))
     #+end_src

     Pandoc can convert almost any text format to org-mode
     representation. One of the current drawbacks - it cannot import online
     web pages.

**** Capture web-pages
     https://github.com/renatgalimov/org-basb-code#emacs-config=
***** org-web-tools

      org-web-tools offers org-web-tools-read-url-as-org function, which can download an URL to an org buffer.

      #+begin_src emacs-lisp
        (use-package org-web-tools
          :ensure t
          :pin "melpa-stable"
          :bind (("C-c n u" . org-web-tools-read-url-as-org)))
      #+end_src

      Often, downloaded files need manual cleanup.
      Firefox web-clipper and Pandoc

      An alternative approach is to use a web-clipper and Pandoc.

      Open the web article in your browser and activate a web-clipper. I use Firefoxes built-in one.
      Save entire HTML into a file.
      Convert the HTML with Pandoc

      pandoc -f html -t org <source-file>.html -o <target-file>.org


      The resulting file might require some cleanup, but the quality of the output is the best among other methods.

***** Capture templates

      <<Please, contribute your capture templates>>
      Finding your own records

      Crawling over your own notes is a key part of the project workflow.

      Below I summarized information about all full-text search engines I found for org-mode.

      Depending on your own need you might select one or multiple of them.

      Unfortunately, I didn’t find any ideal solution for a full-text search yet. Packages that make better sorting are slower than packages that give results fast but in a random order.
      Org full-text search

      Requested features:
      helm or counsel integration.
      live search.
      result previewing support.
      a key-binding to capture results into currently clocked org file.
      results ordering support
      Headlines
      Summary
      Hightlight
      large file-sets support
      ITEM	FRONTEND	SPEED	SORT
      Org-roam Full-text search
      \_ ripgrep (helm-rg)	helm ivy	fast	nil
      \_ helm-org-rifle	helm	slow	t
      \_ deft	helm	fast	nil
      \_ org-ql	helm	slow
      \_ recoll	helm ivy	fast	nil
      \_ org-fts	ivy	fast
      \_ org-agenda search

      ripgrep (helm-rg)

      GitHub - cosmicexplorer/helm-rg: ripgrep is nice Now I use it as a default text search engine.

      brew install ripgrep


      # (use-package helm-rg
      #   :ensure t
      #   :after org-roam
      #   :pin "melpa-stable"
      #   :config
      #   (defun helm-rg-roam-directory (&optional query)
      #     "Search with rg in your roam directory, QUERY."
      #     (interactive)
      #     (let ((helm-rg-default-directory org-roam-directory)
      #           (helm-rg--current-dir org-roam-directory))
      #       (helm-rg query nil)))
      #   :bind (("C-c n R" . helm-rg-roam-directory)))


      helm-org-rifle

      GitHub - alphapapa/org-rifle: Rifle through your Org-mode buffers and acquire your target

      This one is good. It gives you an idea about the context. But it’s not ordering the data by the highlights.

      I find org-rifle too slow at the moment. But its output is exacly what I want.

      # (use-package helm-org-rifle :ensure t
      #   :after org-roam
      #   :pin "melpa-stable"
      #   :config
      #   (defun org-rifle-roam-directory ()
      #     (interactive)
      #     (helm-org-rifle-directories org-roam-directory))
      #   :bind (("C-c n s" . org-rifle-roam-directory)))


      deftGitHub - dfeich/helm-deft: A helm based Emacs module to help search in a predetermined list of directories. Inspired by the deft module.

      Helm implementation didn’t work for me. So I set a default version here.

      One of the drawbacks here is that you can’t see the text you matched. From my point of view - helm-rg gives more precise information about the context.

      # (use-package deft :ensure t
      #   :after org-roam
      #   :config (setq deft-directory org-roam-directory
      #                 deft-recursive t)
      #   :bind (("C-c n d" . deft)))
      # ;; (use-package helm-deft
      # ;;   :ensure t
      # ;;   :straight (:host github
      # ;;                    :repo "dfeich/helm-deft"
      # ;;                    :files ("*.el"))
      # ;;   :config
      # ;;   (setq helm-deft-dir-list `(,org-roam-directory)
      # ;;         helm-deft-extension '("org"))
      # ;;   :bind (("C-c n d" . helm-deft)))



      org-qlGitHub - alphapapa/org-ql: An Org-mode query language, including search commands and saved views

      Doesn’t look suitable for large filesets, but helm implementation is good for medium-sized collections.

      (use-package org-ql :ensure t
      :after org
      :config
      (setq org-ql-search-directories-files-recursive t
      org-ql-search-directories-files-regexp ".org\\(_archive\\)?$"))

      # (use-package helm-org-ql :ensure t
      #   :after org-ql
      #   :config
      #   (setq helm-org-ql-recursive-paths t)x#   :bind (("C-c n q" . helm-org-ql-org-directory)))


      recollGitHub - emacs-helm/helm-recoll: helm interface for the recoll desktop search tool. I found recoll being to hard to set up. I wasn’t able to get it working on MacOS.org-ftsmicrofts/elisp at main · zot/microfts · GitHub

      It didn’t work on MacOS from scratch.
      I tried to compile its binary manually but that didn’t work either.
      This one looks promising. Let’s keep an eye on it.

      org-agenda search

      Not trying this for now because agenda wants to open all its files for search.



**** Deft

     [[https://jblevins.org/projects/deft/][Deft]] provides a nice interface for browsing and filtering org-roam notes.

     #+begin_src emacs-lisp
       (use-package deft
         :after org
         :bind
         ("C-c n D" . deft)
         :custom
         (deft-recursive t)
         (deft-use-filter-string-for-filename t)
         (deft-default-extension "org")
         (deft-directory ssmm-orgfiles-dir)
         (deft-text-mode 'org-mode)
         )
       
     #+end_src
**** Org roam UI
     Can't get 'pdf-tools-install' to work under termux
     #+begin_src emacs-lisp
       (unless (ssmm/is-termux-p)
         (use-package org-roam-ui
           :ensure t
           :after org-roam
           ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
           ;;         a hookable mode anymore, you're advised to pick something yourself
           ;;         if you don't care about startup time, use
           :hook (after-init . org-roam-ui-mode)
           :config
           (setq org-roam-ui-sync-theme t
                 org-roam-ui-follow t
                 org-roam-ui-update-on-save t
                 org-roam-ui-open-on-start t))
         )
     #+end_src
**** Distill
***** Progressive summarization
      Make org-emphasize multi-linear

      To bypass the limit of two lines for org-emphasize marks enable the code below.

      ;; Make org-emphasis to work on up to 10 lines selection.
      #+begin_src emacs-lisp
        (setcar (nthcdr 4 org-emphasis-regexp-components) 10)
        (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
      #+end_src

***** Highlighting

      Highlighting is a key part of progressive summarization. Here I will be highlighting with highlight.el and enriched mode. If you don’t want to put your text file into the enriched text mode, you can use org-emphasize instead of functions provided here.
      highlight.el

      When working with plain text buffers, like org-mode or markdown, you can use enriched text mode with the highlight library to mark the text.

      #+begin_src emacs-lisp
        ;; If you get errors saying something about facemenu, try
        ;; uncommenting this.
        ;; (setq facemenu-menu nil)
        
        (use-package highlight :ensure t
                     :config
                     (defun hlt-general()
                       (interactive)
                       (unless (bound-and-true-p enriched-mode)
                         (enriched-mode t))
                       (hlt-highlight-region (region-beginning) (region-end) 'highlight))
        
                     :bind (("C-c n h" . hlt-general)
                            ("C-c n H" . hlt-unhighlight-region)))
        
        
        ;; If you cannot save your enriched files because of the :inherit
        ;; error, try uncommenting this function.
        
        ;; (defun enriched-face-ans (face)
        ;;   "Return annotations specifying FACE.
        ;; FACE may be a list of faces instead of a single face;
        ;; it can also be anything allowed as an element of a list
        ;; which can be the value of the `face' text property."
        ;;   (cond ((and (consp face) (eq (car face) 'foreground-color))
        ;;          (list (list "x-color" (cdr face))))
        ;;         ((and (consp face) (eq (car face) 'background-color))
        ;;          (list (list "x-bg-color" (cdr face))))
        ;;         ((and (listp face) (eq (car face) :foreground))
        ;;          (list (list "x-color" (cadr face))))
        ;;         ((and (listp face) (eq (car face) :background))
        ;;          (list (list "x-bg-color" (cadr face))))
        ;;         ((and (listp face) (eq (car face) :inherit))
        ;;          (enriched-face-ans (cdr face)))
        ;;         ((listp face)
        ;;          (apply 'append (mapcar 'enriched-face-ans face)))
        ;;         ((let* ((fg (face-attribute face :foreground))
        ;;                 (bg (face-attribute face :background))
        ;;                 (props (face-font face t))
        ;;                 (ans (cdr (format-annotate-single-property-change
        ;;                            'face nil props enriched-translations))))
        ;;            (unless (eq fg 'unspecified)
        ;;              (setq ans (cons (list "x-color" fg) ans)))
        ;;            (unless (eq bg 'unspecified)
        ;;              (setq ans (cons (list "x-bg-color" bg) ans)))
        ;;            ans))))
      #+end_src

***** org-capture a region

      To keep track of highlighted notes we will use org-capture.

      ;; Use =org-capture f= to put a link to the text you selected.into an
      ;; org entry with the current timer enabled.

      #+begin_src emacs-lisp
        (defun r/org-capture-get-selected-text ()
          (with-current-buffer (org-capture-get :original-buffer)
            (string-trim
             (replace-regexp-in-string
              "\n" " "
              (cond ((eq major-mode 'pdf-view-mode)
                     (pdf-info-gettext (pdf-view-current-page) (car (pdf-view-active-region))))
                    (t (buffer-substring-no-properties (region-beginning) (region-end))))))))
        (defun r/org-capture-get-link (path)
          (with-current-buffer (org-capture-get :original-buffer)
            (cond ((eq major-mode 'pdf-view-mode) (switch-to-buffer (org-capture-get :original-buffer)) (org-pdftools-get-link))
                  (t (concat path "::" (r/org-capture-get-selected-text))))))
        
        (with-eval-after-load "org-capture"
          (add-to-list
           'org-capture-templates
           '("f" "Curently watched" item (clock)
             "%(r/org-capture-get-selected-text) [[%(r/org-capture-get-link \"%F\")][↗]]%?" :unnarrowed t)))
        
        ;; The code below automatically highlights the region we captured
        (defun do-highlight-on-capture ()
          "Highlight selected region of the buffer you were in at capture."
          (save-excursion
            (with-current-buffer (plist-get org-capture-plist :original-buffer)
              (cond ((eq major-mode 'pdf-view-mode) (switch-to-buffer (org-capture-get :original-buffer)) (pdf-annot-add-highlight-markup-annotation (car (pdf-view-active-region))))
                    (t (hlt-general))))))
        (defun highlight-on-capture ()
          (when (equal (plist-get org-capture-plist :key) "f")
            (do-highlight-on-capture)))
        
        (add-hook 'org-capture-after-finalize-hook #'highlight-on-capture)
      #+end_src

      This is my basic marking mechanism. Whenever I’m reading an article in
      Emacs (transformed to an org-mode or markdown file), I click C-c f to
      insert an entry to the notebook I’m currently on.

      attachments/highlighting-with-org-capture.gif
***** Working with PDF files

      Don’t forget to install pdf-tools dependencies.

      brew install glib

      #+begin_src emacs-lisp
        ;; (use-package pdf-tools
        ;;   :ensure t
        
        ;;   :straight (:host github
        ;;                    :repo "matthew-piziak/pdf-tools"
        ;;                    :files ("lisp/*.el" "server"))
        ;;   :config
        ;;   (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode))
        ;;   (let ((pdf-tools-base-dir (expand-file-name  "straight/repos/pdf-tools/server" straight-base-dir)))
        ;;     (setq pdf-info-epdfinfo-program (expand-file-name "straight/repos/pdf-tools/server/epdfinfo" straight-base-dir))
        ;;     (condition-case nil
        ;;         (pdf-info-check-epdfinfo)
        ;;       (error (let ((default-directory (file-name-directory pdf-info-epdfinfo-program)))
        ;;                (pdf-tools-install t t))))))
        
        
        ;; (use-package org-pdftools
        ;;   :ensure t
        ;;   :hook (org-mode . org-pdftools-setup-link))
      #+end_src

**** Org-journal

     [[https://github.com/bastibe/org-journal][Org-journal]] is a more powerful alternative to the simple function org-roam-today. It provides better journaling capabilities, and a nice calendar interface to see all dated entries.

     #+begin_export emacs-lisp
     (use-package org-journal
       :bind
       ("C-c n j" . org-journal-new-entry)
       :custom
       (org-journal-date-prefix "#+TITLE: ")
       (org-journal-file-format "%Y-%m-%d.org")
       (org-journal-dir ssmm-org-roam-dir)
       (org-journal-date-format "%A, %d %B %Y"))
     #+end_export

**** Org-download

     [[https://github.com/abo-abo/org-download][Org-download]] lets you screenshot and yank images from the web into your notes:

     #+begin_src emacs-lisp
       (use-package org-download
         :after org
         :bind
         (:map org-mode-map
               (("s-Y" . org-download-screenshot)
                ("s-y" . org-download-yank))))
     #+end_src

**** mathpix.el

     [[https://github.com/jethrokuan/mathpix.el][mathpix.el]] uses [[https://mathpix.com/][Mathpix's]] API to convert clips into latex equations:

     #+begin_src emacs-lisp
       ;; (use-package mathpix.el
       ;;   :straight (:host github :repo "jethrokuan/mathpix.el")
       ;;   :custom ((mathpix-app-id "app-id")
       ;;            (mathpix-app-key "app-key"))
       ;;   :bind
       ;;   ("C-x m" . mathpix-screenshot))
     #+end_src

**** Org-noter / Interleave

     [[https://github.com/weirdNox/org-noter][Org-noter]] and Interleave are both projects that allow synchronised
     annotation of documents (PDF, EPUB etc.) within Org-mode.

     TODO: Is there some problem with pdf-tools (on all
     devices)? It is commented-out [2023-03-20 Mon]
     #+begin_src emacs-lisp
       ;; (unless (ssmm/is-termux-p)
       ;;   (use-package org-noter
       ;;     :after org
       ;;     :config
       ;;     (setq org-noter-default-notes-file-names '("noter.org"))
       ;;     (setq org-noter-notes-search-path '(concat ssmm-orgfiles-dir "notes"))
       ;;     )
       ;;   )
       
     #+end_src


**** Spaced Repetition

     [[https://github.com/l3kn/org-fc/][Org-fc]] is a spaced repetition system that scales well with a large
     number of files. Other alternatives include org-drill, and pamparam.

     #+begin_src emacs-lisp
       ;; (use-package org-fc
       ;;   :straight (org-fc :type git :host github :repo "l3kn/org-fc")
       ;;   :custom
       ;;   (org-fc-directories '("~/org/fc/"))
       ;;   :config
       ;;   (require 'org-fc-hydra))
     #+end_src

*** General org-y stuff

    Enable misc org modules:
    #+begin_src emacs-lisp
      (setq org-modules (quote
                         (org-bbdb
                          org-bibtex
                          org-crypt
                          org-gnus
                          org-id
                          org-info
                          org-habit
                          org-inlinetask
                          org-irc
                          org-mew
                          org-mhe
                          org-protocol
                          org-rmail
                          org-vm
                          org-wl
                          org-w3m
                          )
                         )
            )
    #+end_src
    Common org tags.
    #+begin_src emacs-lisp
      ;; (setq org-tag-alist '(("project" . ?p)
      ;;                       (:startgrouptag)
      ;;                       ("GTD")
      ;;                       (:grouptags)
      ;;                       ("@work" . ?w)
      ;;                       ("@home" . ?h)
      ;;                       ("@yard" . ?y)
      ;;                       ("@computer" . ?c)
      ;;                       (:endgrouptag)))
    #+end_src
*** habits

    «Org has the ability to track the consistency of a special category of
    TODOs, called “habits”.»

    - http://orgmode.org/manual/Tracking-your-habits.html
    - http://orgmode.org/worg/org-tutorials/tracking-habits.html

    - global STYLE property values for completion
      #+begin_src emacs-lisp
        (setq org-global-properties (quote (("STYLE_ALL" . "habit"))))
      #+end_src

      - position the habit graph on the agenda to the right of the default
        #+begin_src emacs-lisp
          (setq org-habit-graph-column 50)
        #+end_src

        #+begin_src emacs-lisp
          
          ;; Automatically tracks when TODO items are DONEd.
          (setq org-log-done 'time)
          
          (defun ssmm-org-make-checkbox ()
            "Make this line into a checkbox"
            (interactive)
            (beginning-of-line)
            (insert " - [ ] "))
          
          (defun ssmm-org-auto-fill ()
            (if (string-match-p "^[0-9]+\.org" (buffer-name)) (auto-fill-mode 1))
            )
          
          (defun my-org-mode-hook ()
            (local-set-key (kbd "C-c C-<f9>") 'ssmm-org-make-checkbox)
            (local-set-key (kbd "C-<f9>") 'org-metaright)
            (ssmm-org-auto-fill)
            )
          
          (add-hook 'org-mode-hook 'my-org-mode-hook t)
                                                  ;(setq prelude-org-mode-hook nil)
          
          (defun ssmm-org-make-checkbox ()
            "Make this line into a checkbox"
            (interactive)
            (beginning-of-line)
            (insert " - [ ] "))
          
          (defun ssmm-org-auto-fill ()
            (if (string-match-p "^[0-9]+\.org" (buffer-name)) (auto-fill-mode 1))
            )
          
          (defun my-org-mode-hook ()
            (local-set-key (kbd "C-c C-<f9>") 'ssmm-org-make-checkbox)
            (local-set-key (kbd "C-<f9>") 'org-metaright)
            (ssmm-org-auto-fill)
            )
          
          (add-hook 'org-mode-hook 'my-org-mode-hook t)
                                                  ;(setq prelude-org-mode-hook nil)
          
          (defun ssmm/org-open-other-frame ()
            "Jump to bookmark in another frame. See `bookmark-jump' for more."
            (interactive)
            (let ((org-link-frame-setup (acons 'file 'find-file-other-frame org-link-frame-setup)))
              (org-open-at-point)))
          
        #+end_src

*** Org agenda
    org agenda stuff is from
    [[https://raw.githubusercontent.com/novoid/dot-emacs/master/config.org][Karl Voit's config file]] and
    [[https://github.com/alphapapa/org-super-agenda][Supercharge your Org daily/weekly agenda by grouping items]]

    #+begin_src emacs-lisp
                                              ;  (with-package* org-super-agenda
                                              ;  )
    #+end_src
    <2017-10-07 Sat>
    Definition of =my-super-agenda-groups=, my central configuration of super-agenda:

    #+begin_src emacs-lisp
                                              ;  (setq my-super-agenda-groups
                                              ;        '(;; Each group has an implicit boolean OR operator between its selectors.
                                              ;          (:name "Today"  ; Optionally specify section name
                                              ;                 :time-grid t  ; Items that appear on the time grid
                                              ;                 )
                                              ;          (:name "Important" :priority "A")
                                              ;          (:priority<= "B"
                                              ;                       ;; Show this section after "Today" and "Important", because
                                              ;                       ;; their order is unspecified, defaulting to 0. Sections
                                              ;                       ;; are displayed lowest-number-first.
                                              ;                       :order 1)
                                              ;          ;; no habits yet? (:name "Habits" :habit t :order 2)
                                              ;          (:name "Shopping" :tag "Shopping" :order 3)
                                              ;                 ;; Boolean AND group matches items that match all subgroups
                                              ;                 ;;  :and (:tag "shopping" :tag "@town")
                                              ;                 ;; Multiple args given in list with implicit OR
                                              ;                 ;;  :tag ("food" "dinner"))
                                              ;                 ;;  :habit t
                                              ;                 ;;  :tag "personal")
                                              ;          (:name "Started" :todo "STARTED" :order 5)
                                              ;          ;;(:name "Space-related (non-moon-or-planet-related)"
                                              ;          ;;       ;; Regexps match case-insensitively on the entire entry
                                              ;          ;;       :and (:regexp ("space" "NASA")
                                              ;          ;;                     ;; Boolean NOT also has implicit OR between selectors
                                              ;          ;;                     :not (:regexp "moon" :tag "planet")))
                                              ;          (:todo "WAITING" :order 9)  ; Set order of this section
                                              ;          (:name "read" :tag "2read" :order 15)
                                              ;          ;; Groups supply their own section names when none are given
                                              ;          (:todo ("SOMEDAY" "WATCHING")
                                              ;                 ;; Show this group at the end of the agenda (since it has the
                                              ;                 ;; highest number). If you specified this group last, items
                                              ;                 ;; with these todo keywords that e.g. have priority A would be
                                              ;                 ;; displayed in that group instead, because items are grouped
                                              ;                 ;; out in the order the groups are listed.
                                              ;                 :order 25)
                                              ;          (:name "reward"
                                              ;                 :tag ("reward" "lp")
                                              ;                 :order 100
                                              ;                 )
                                              ;
                                              ;          ;; After the last group, the agenda will display items that didn't
                                              ;          ;; match any of these groups, with the default order position of 99
                                              ;
                                              ;        )
                                              ;      )
    #+end_src

    =my-super-agenda()= is a function so that I am able to call the agenda
    interactively or within =my-org-agenda()= which is defined further
    down below.

    #+begin_src emacs-lisp
      ;;  (defun my-super-agenda()
                                              ;   "generates my super-agenda"
                                              ;    (interactive)
                                              ;    (org-super-agenda-mode)
                                              ;    (let
                                              ;        ((org-super-agenda-groups my-super-agenda-groups))
                                              ;      (org-agenda nil "a")
                                              ;      )
                                              ;    )
    #+end_src

*** org-agenda-custom-commands → long list of agenda definitions
    #+begin_src emacs-lisp
      (setq org-agenda-custom-commands
            '(("cd" "DONE TODOs sorted by date"
               todo "DONE"
               ((org-agenda-overriding-header "\nTODOs sorted by state, priority, effort")
                (org-agenda-sorting-strategy '(todo-state-down time-down))))))
    #+end_src
    #+begin_src emacs-lisp
                                              ;  (setq org-agenda-custom-commands
                                              ;        (quote (
                                              ;
                                              ;                ("b" "Super Agenda" agenda ""
                                              ;                 (org-super-agenda-mode)
                                              ;                 ((org-super-agenda-groups my-super-agenda-groups))
                                              ;                 (org-agenda nil "a"))
                                              ;
                                              ;                ("A" "Agenda" agenda ""
                                              ;                 (org-agenda nil "a"))
                                              ;
                                              ;                ("n" "no TODO events +180d"
                                              ;                 ((agenda "no TODO events +180d"
                                              ;                          ((org-agenda-span 180)
                                              ;                           (org-agenda-time-grid nil)
                                              ;                           (org-agenda-entry-types '(:timestamp :sexp))
                                              ;                           (org-agenda-skip-function
                                              ;                            '(or
                                              ;                              (org-agenda-skip-entry-if 'todo 'any);; skip if any TODO state is found
                                              ;                              (org-agenda-skip-entry-if 'category "infonova");; skip if any TODO state is found
                                              ;                              (my-skip-tag "lp")
                                              ;                              )
                                              ;                            )
                                              ;                           ;;(org-agenda-skip-function '(my-skip-tag "lp"))
                                              ;                          )))
                                              ;                 nil ("~/org/agenda_180d_filtered.html"))
                                              ;
                                              ;                ("D" "detail agenda"
                                              ;                 ((agenda "detail agenda"
                                              ;                          ((org-agenda-span 31)
                                              ;                           (org-agenda-time-grid nil)
                                              ;                          )))
                                              ;                 nil ("~/org/agenda_details.html"))
                                              ;
                                              ;                ("r" "reward tasks" (
                                              ;                                     (tags-todo "reward/!STARTED"
                                              ;                                                (
                                              ;                                                 (org-agenda-overriding-header "rewards: STARTED")
                                              ;                                                 ))
                                              ;                                     (tags-todo "reward/!NEXT"
                                              ;                                                (
                                              ;                                                 (org-agenda-overriding-header "rewards: NEXT")
                                              ;                                                 ))
                                              ;                                     (tags-todo "reward/!TODO"
                                              ;                                                (
                                              ;                                                 (org-agenda-overriding-header "rewards: TODO")
                                              ;                                                 ))
                                              ;                                     (tags-todo "reward/!SOMEDAY"
                                              ;                                                (
                                              ;                                                 (org-agenda-overriding-header "rewards: SOMEDAY")
                                              ;                                                 ))
                                              ;                                     ))
                                              ;                ("i" "issues" (
                                              ;                                     (tags-todo "issue/!STARTED"
                                              ;                                                (
                                              ;                                                 (org-agenda-overriding-header "issues: STARTED")
                                              ;                                                 ))
                                              ;                                     (tags-todo "issue/!NEXT"
                                              ;                                                (
                                              ;                                                 (org-agenda-overriding-header "issues: NEXT")
                                              ;                                                 ))
                                              ;                                     (tags-todo "issue/!TODO"
                                              ;                                                (
                                              ;                                                 (org-agenda-overriding-header "issues: TODO")
                                              ;                                                 ))
                                              ;                                     (tags-todo "issue/!SOMEDAY"
                                              ;                                                (
                                              ;                                                 (org-agenda-overriding-header "issues: SOMEDAY")
                                              ;                                                 ))
                                              ;                                     ))
                                              ;
                                              ;                ("$" "Shopping" tags "+Shopping"
                                              ;                 (
                                              ;                  (org-agenda-overriding-header "Shopping")
                                              ;                  (org-agenda-skip-function 'tag-without-done-or-canceled)
                                              ;                  ))
                                              ;
                                              ;                )))
    #+end_src

    #+RESULTS:
    | a | Super Agenda         | agenda                                                                                                                                                                                                                                                                                                        |            | (org-super-agenda-mode)                                                                                           | ((org-super-agenda-groups my-super-agenda-groups)) | (org-agenda nil a) |
    | A | Agenda               | agenda                                                                                                                                                                                                                                                                                                        |            | (org-agenda nil a)                                                                                                |                                                    |                    |
    | n | no TODO events +180d | ((agenda no TODO events +180d ((org-agenda-span 180) (org-agenda-time-grid nil) (org-agenda-entry-types (quote (:timestamp :sexp))) (org-agenda-skip-function (quote (or (org-agenda-skip-entry-if (quote todo) (quote any)) (org-agenda-skip-entry-if (quote category) infonova) (my-skip-tag lp)))))))      | nil        | (~/org/agenda_180d_filtered.html)                                                                                 |                                                    |                    |
    | D | detail agenda        | ((agenda detail agenda ((org-agenda-span 31) (org-agenda-time-grid nil))))                                                                                                                                                                                                                                    | nil        | (~/org/agenda_details.html)                                                                                       |                                                    |                    |
    | r | reward tasks         | ((tags-todo reward/!STARTED ((org-agenda-overriding-header rewards: STARTED))) (tags-todo reward/!NEXT ((org-agenda-overriding-header rewards: NEXT))) (tags-todo reward/!TODO ((org-agenda-overriding-header rewards: TODO))) (tags-todo reward/!SOMEDAY ((org-agenda-overriding-header rewards: SOMEDAY)))) |            |                                                                                                                   |                                                    |                    |
    | i | issues               | ((tags-todo issue/!STARTED ((org-agenda-overriding-header issues: STARTED))) (tags-todo issue/!NEXT ((org-agenda-overriding-header issues: NEXT))) (tags-todo issue/!TODO ((org-agenda-overriding-header issues: TODO))) (tags-todo issue/!SOMEDAY ((org-agenda-overriding-header issues: SOMEDAY))))         |            |                                                                                                                   |                                                    |                    |
    | B | borrowed             | tags                                                                                                                                                                                                                                                                                                          | +borrowed  | ((org-agenda-overriding-header borrowed or lend) (org-agenda-skip-function (quote tag-without-done-or-canceled))) |                                                    |                    |
    | $ | Besorgungen          | tags                                                                                                                                                                                                                                                                                                          | +Besorgung | ((org-agenda-overriding-header Besorgungen) (org-agenda-skip-function (quote tag-without-done-or-canceled)))      |                                                    |                    |

*** Agenda settings
    start Agenda in log-mode:
    #+begin_src emacs-lisp
      (setq org-agenda-start-with-log-mode t)
    #+end_src
    start Agenda in follow-mode:
    #+begin_src emacs-lisp
                                              ;(setq org-agenda-start-with-follow-mode t)
    #+end_src

    - t = do not initialize agenda Org files when generating (only) agenda
    - nil = initialize normal
    - performance issue when not "t": https://punchagan.muse-amuse.in/posts/how-i-learnt-to-use-emacs-profiler.html
      #+begin_src emacs-lisp
        ;;(setq org-agenda-inhibit-startup nil);; slower but visibility of buffers is correctly shown
        (setq org-agenda-inhibit-startup t);; faster with no hidden headings (agenda performance)
      #+end_src

      Compact the block agenda view
      #+begin_src emacs-lisp
        (setq org-agenda-compact-blocks t)
      #+end_src

      - Changed in v7.9.3
      - http://orgmode.org/worg/doc.html#org-use-tag-inheritance
      - performance issue when not nil: https://punchagan.muse-amuse.in/posts/how-i-learnt-to-use-emacs-profiler.html
        #+begin_src emacs-lisp
          (setq org-agenda-use-tag-inheritance (quote (agenda)));; agenda performance
        #+end_src

        http://orgmode.org/org.html#Weekly_002fdaily-agenda
        #+begin_src emacs-lisp
          (setq org-agenda-span 'week)
        #+end_src

        For tag searches ignore tasks with scheduled and deadline dates
        #+begin_src emacs-lisp :tangle no
          (setq org-agenda-tags-todo-honor-ignore-options t)
        #+end_src

        Always hilight the current agenda line
        #+begin_src emacs-lisp
          (add-hook 'org-agenda-mode-hook '(lambda () (hl-line-mode 1)))
        #+end_src

        The following custom-set-faces create the highlights
        #+begin_src emacs-lisp :tangle no
          (custom-set-faces
           ;; custom-set-faces was added by Custom.
           ;; If you edit it by hand, you could mess it up, so be careful.
           ;; Your init file should contain only one such instance.
           ;; If there is more than one, they won't work right.
           '(highlight ((t (:background "cyan"))))
           '(hl-line ((t (:inherit highlight :background "darkseagreen2"))))
           '(org-mode-line-clock ((t (:background "grey75" :foreground "red" :box (:line-width -1 :style released-button)))) t))
        #+end_src

        Keep tasks with dates off the global todo lists:
        #+begin_src emacs-lisp
          (setq org-agenda-todo-ignore-with-date nil)
        #+end_src

        Allow deadlines which are due soon to appear on the global todo lists:
        #+begin_src emacs-lisp
          (setq org-agenda-todo-ignore-deadlines (quote far))
        #+end_src

        Keep tasks scheduled in the future off the global todo lists
        #+begin_src emacs-lisp
          (setq org-agenda-todo-ignore-scheduled (quote future))
        #+end_src

        Remove completed deadline tasks from the agenda view
        #+begin_src emacs-lisp
          (setq org-agenda-skip-deadline-if-done t)
        #+end_src

        Remove completed scheduled tasks from the agenda view
        #+begin_src emacs-lisp
          (setq org-agenda-skip-scheduled-if-done t)
        #+end_src

        Remove completed items from search results
        #+begin_src emacs-lisp :tangle no
          (setq org-agenda-skip-timestamp-if-done t)
        #+end_src

        Include agenda archive files when searching for things
        #+begin_src emacs-lisp
          (setq org-agenda-text-search-extra-files (quote (agenda-archives)))
        #+end_src

        show state changes in log-mode of agenda
        #+begin_src emacs-lisp
          (setq org-agenda-log-mode-items (quote (state)))
        #+end_src

        http://orgmode.org/worg/org-faq.html
        #+begin_src emacs-lisp
                                                  ;(setq org-agenda-skip-additional-timestamps-same-entry t)
          (setq org-agenda-skip-additional-timestamps-same-entry nil)
        #+end_src

        do not search for time in heading when displaying a date-stamp
        #+begin_src emacs-lisp
          (setq org-agenda-search-headline-for-time nil)
        #+end_src

        open agenda in same buffer, full size
        #+begin_src emacs-lisp
          (setq org-agenda-window-setup 'current-window)
        #+end_src

        add diary entries in agenda view
        http://orgmode.org/org.html#Weekly_002fdaily-agenda
        #+begin_src emacs-lisp
          (setq org-agenda-include-diary t)
        #+end_src

        Increase the size of the filename column for org-agenda so org-roam
        files aren't wierd looking.
        #+begin_src emacs-lisp
          (setq org-agenda-prefix-format
                '((agenda . " %i %(vulpea-agenda-category 12)%?-12t% s")
                  (todo . " %i %(vulpea-agenda-category 12) ")
                  (tags . " %i %(vulpea-agenda-category 12) ")
                  (search . " %i %(vulpea-agenda-category 12) ")))
          
          ;; From https://d12frosted.io/posts/2020-06-24-task-management-with-roam-vol2.html
          
          (defun vulpea-agenda-category (&optional len)
            "Get category of item at point for agenda.
          
          Category is defined by one of the following items:
          
          - CATEGORY property
          - TITLE keyword
          - TITLE property
          - filename without directory and extension
          
          When LEN is a number, resulting string is padded right with
          spaces and then truncated with ... on the right if result is
          longer than LEN.
          
          Usage example:
          
            (setq org-agenda-prefix-format
                  '((agenda . \" %(vulpea-agenda-category) %?-12t %12s\")))
          
          Refer to `org-agenda-prefix-format' for more information."
            (let* ((file-name (when buffer-file-name
                                (file-name-sans-extension
                                 (file-name-nondirectory buffer-file-name))))
                   (title (vulpea-buffer-prop-get "title"))
                   (category (org-get-category))
                   (result
                    (or (if (and
                             title
                             (string-equal category file-name))
                            title
                          category)
                        "")))
              (if (numberp len)
                  (s-truncate len (s-pad-right len " " result))
                result)))
        #+end_src

        Show all future entries for repeating tasks
        #+begin_src emacs-lisp
          (setq org-agenda-repeating-timestamp-show-all t)
        #+end_src

        Show all agenda dates - even if they are empty
        #+begin_src emacs-lisp
          (setq org-agenda-show-all-dates t)
        #+end_src

        Sorting order for tasks on the agenda
        #+begin_src emacs-lisp
          (setq org-agenda-sorting-strategy
                (quote ((agenda habit-down time-up user-defined-up priority-down category-keep)
                        (todo priority-down category-keep)
                        (tags priority-down category-keep)
                        (search category-keep))))
        #+end_src

        Start the weekly agenda today
        #+begin_src emacs-lisp
          (setq org-agenda-start-on-weekday nil)
        #+end_src

        Non-nil means skip timestamp line if same entry shows because of deadline.
        #+begin_src emacs-lisp
          (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
        #+end_src

        Agenda sorting functions
        #+begin_src emacs-lisp
          (setq org-agenda-cmp-user-defined 'bh/agenda-sort)
        #+end_src

        Enable display of the time grid so we can see the marker for the current time
        #+begin_src emacs-lisp :tangle no
          ;; (setq org-agenda-time-grid
          ;;       ((daily today remove-match)
          ;;        #("----------------" 0 16
          ;;          (org-heading t))
          ;;        (800 1000 1200 1400 1600 1800 2000)))
        #+end_src

        Display tags farther right
        #+begin_src emacs-lisp
          (setq org-tags-column -80)
                                                  ; should *not* differ between
                                                  ; systems! Otherwise Org-files gets
                                                  ; re-formatted after switching
                                                  ; system
          (setq org-agenda-tags-column (- (- (window-total-width) 3))) ;; total width minus 3
        #+end_src

        Sticky agendas remain opened in the background so that you don't
        need to regenerate them each time you hit the corresponding
        keystroke. This is a big time saver.
        #+begin_src emacs-lisp :tangle no
          (setq org-agenda-sticky t)
        #+end_src

*** Agenda category icons

    There is the possibility of adding icons to categories:
    http://julien.danjou.info/blog/2010/icon-category-support-in-org-mode

    This is a neat way of beautifying the agenda.

    Unfortunately, the clean way of defining the data directory relatively
    to the path stored in =my-user-emacs-directory= does not work:
    : (concat my-user-emacs-directory "bin/R6-logo_18x12.jpg") nil nil :ascent center)

    I don't know how to fix this and so I stick with the hard coded path
    and with a bleeding heart.

    #+begin_src emacs-lisp
      (setq org-agenda-category-icon-alist nil)
                                              ;(when (my-system-type-is-windows)
      (add-to-list 'org-agenda-category-icon-alist
                   '(".*" '(space . (:width (16))))
                   )
      ;;    (add-to-list 'org-agenda-category-icon-alist
      ;;                '("r6" "~/.emacs.d/bin/R6-logo_18x12.jpg" nil nil :ascent center)
      ;;                )
      ;;    (add-to-list 'org-agenda-category-icon-alist
      ;;                '("infonova" "~/.emacs.d/bin/R6-logo_18x12.jpg" nil nil :ascent center)
      ;;                )
      (add-to-list 'org-agenda-category-icon-alist
                   '("detego" "~/.emacs.d/bin/detego-inwarehouse-logo-D_only_16x16.png" nil nil :ascent center)
                   )
      (add-to-list 'org-agenda-category-icon-alist
                   '("outlook" "~/.emacs.d/bin/detego-inwarehouse-logo-D_only_16x16.png" nil nil :ascent center)
                   )
      ;;(add-to-list 'org-agenda-category-icon-alist
      ;;           '("misc" '(space . (:width (18))))
      ;;           )
                                              ;  )
      
      ;; (when (and (not (my-system-type-is-windows)) (not (my-system-is-karl-voit-at)))
      (add-to-list 'org-agenda-category-icon-alist
                   '(".*" '(space . (:width (16))))
                   )
      (add-to-list 'org-agenda-category-icon-alist
                   '("contacts" "~/.emacs.d/bin/user-identity.png" nil nil :ascent center)
                   ;; /usr/share/icons/gnome/16x16/emotes/face-smile.png
                   )
      (add-to-list 'org-agenda-category-icon-alist
                   '("public_voit" "~/.emacs.d/bin/application-rss+xml.png" nil nil :ascent center)
                   ;; /usr/share/icons/oxygen/16x16/mimetypes/application-rss+xml.png
                   )
      ;;    (add-to-list 'org-agenda-category-icon-alist
      ;;               '("misc" "~/.emacs.d/bin/emblem-new.png" nil nil :ascent center)
      ;;                 ;; /usr/share/icons/oxygen/16x16/emblems/emblem-new.png
      ;;                )
      (add-to-list 'org-agenda-category-icon-alist
                   '("hardware" "~/.emacs.d/bin/camera-photo.png" nil nil :ascent center)
                   ;; /usr/share/icons/oxygen/16x16/devices/camera-photo.png
                   )
      (add-to-list 'org-agenda-category-icon-alist
                   '("bwg" "~/.emacs.d/bin/go-home.png" nil nil :ascent center)
                   ;; /usr/share/icons/oxygen/16x16/actions/go-home.png
                   )
      ;;   )
    #+end_src

*** my-org-agenda() → my-map a

    switch to open Agenda or open new one:
    #+begin_src emacs-lisp
      (defun my-org-agenda ()
        "Opens the already opened agenda or opens new one instead"
        (interactive)
      
        (setq my-org-agenda-tags-column (- (- (window-total-width) 3)))
        (setq org-agenda-tags-column my-org-agenda-tags-column) ;; total width minus 3
      
        (if (my-buffer-exists "*Org Agenda*")
            (switch-to-buffer "*Org Agenda*")
          ;;;(my-super-agenda)
          )
        )
      ;;(bind-key "a" 'my-org-agenda my-map)
    #+end_src

*** my-memacs-org-agenda() → my-map m     C-cm

    Memacs org-agenda shortcut
    #+begin_src emacs-lisp
      (defun my-memacs-org-agenda ()
        "Opens an org-agenda with activated archive"
        (interactive)
        ;;(setq org-agenda-files (append (quote ("~/org/issues.org"))));; for testing purposes
        (org-agenda-list)
        ;;(call-interactively 'org-agenda-log-mode)
        (org-agenda-log-mode '(4))
        (call-interactively 'org-agenda-archives-mode)
        (org-agenda-archives-mode 'files)
        )
      ;;disabled because I needed "m";; (bind-key "m" 'my-memacs-org-agenda my-map)
      (global-set-key "\C-cm" 'my-memacs-org-agenda)
    #+end_src

    My org-agenda files are set in the various customization files.

*** Projects
    From
    #+begin_src emacs-lisp
      (defun my-mark-as-project ()
        "This function makes sure that the current heading has
      (1) the tag :project:
      (2) has property COOKIE_DATA set to \"todo recursive\"
      (3) has any TODO keyword and
      (4) a leading progress indicator"
        (interactive)
        (org-toggle-tag "project" 'on)
        (org-set-property "COOKIE_DATA" "todo recursive")
        (org-back-to-heading t)
        (let* ((title (nth 4 (org-heading-components)))
               (keyword (nth 2 (org-heading-components))))
          (when (and (bound-and-true-p keyword) (string-prefix-p "[" title))
            (message "TODO keyword and progress indicator found")
            )
          (when (and (not (bound-and-true-p keyword)) (string-prefix-p "[" title))
            (message "no TODO keyword but progress indicator found")
            (forward-whitespace 1)
            (insert "NEXT ")
            )
          (when (and (not (bound-and-true-p keyword)) (not (string-prefix-p "[" title)))
            (message "no TODO keyword and no progress indicator found")
            (forward-whitespace 1)
            (insert "NEXT [/] ")
            )
          (when (and (bound-and-true-p keyword) (not (string-prefix-p "[" title)))
            (message "TODO keyword but no progress indicator found")
            (forward-whitespace 2)
            (insert "[/] ")
            )
          )
        )
    #+end_src
*** Capturing

    #+begin_src emacs-lisp
      (setq org-capture-templates '(("t" "Todo [inbox]" entry
                                     (file+headline ssmm-org-inbox-file "Tasks")
                                     "* TODO %i%?")
                                    ("T" "Tickler" entry
                                     (file+headline ssmm-org-inbox-file "Tickler")
                                     "* %i%? \n %U")
                                    ("j" "Journal" entry (file+datetree ssmm-org-main-file)
                                     "* %?\nEntered on %T\n  %i\n" :clock-keep t)
                                    ("J" "JournalJJ" entry (file+olp+datetree ssmm-org-main-file)
                                     "* %?\nEntered on %T\nurl %:link  %i\n" :clock-keep t)
                                    ("p" "New project entry" entry (file+olp ssmm-org-main-file "Projects")
                                     "* %?\nEntered on %T\n" :unnarrowed t)
                                    ("Q" "quote org capture" entry
                                     (file+headline ssmm-org-inbox-file "Unsorted")
                                     "* %?%:description Added %U
      ,#+BEGIN_QUOTE
      %x
      ,#+END_QUOTE" :immediate-finish t)
                                    )
            )
      
      (global-set-key "\C-cl" 'org-store-link)
      (global-set-key "\C-cc" 'org-capture)
      (global-set-key "\C-ca" 'org-agenda)
      (global-set-key "\C-cb" 'org-iswitchb)
      
      (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
      ;; (setq org-refile-targets '((ssmm-org-main-file :maxlevel . 3)
      ;;                            (ssmm-org-tickler-file :maxlevel . 2)))
      
      (defun ssmm-get-project-org-file ()
        "If the .dir-locals.el file (or other) has defined project-org-file, use it,
           otherwise, look up the directory tree for the first one."
        (or (and (boundp 'project-org-file)
                 (symbol-value 'project-org-file))
            (concat (locate-dominating-file (buffer-file-name) "project.org") "project.org")
            ))
      
      (add-to-list 'org-capture-templates `("c" "Command" entry
                                            (file+olp+datetree ssmm-get-project-org-file
                                                               "Commands")
                                            "* %?\n#+begin_src sh\n%i\n#+end_src\n"))
      
      (add-to-list 'org-capture-templates `("p" "Project Notes" entry
                                            (file+olp+datetree ssmm-get-project-org-file
                                                               "Notes")
                                            "* %?\n"))
      (put 'project-org-file 'safe-local-variable #'stringp)
      
      
      (defun ssmm-get-projects ()
        "Get a list of current projects.
               This will be a list of the 2nd-level headings under a 1st-level
               heading named 'Projects', in `ssmm-org-main-file'.
               "
        (interactive)
        (with-current-buffer (file-name-nondirectory ssmm-org-main-file)
          (org-element-map (org-element-parse-buffer) 'headline
            (lambda (headline)
              (let* ((parent (org-element-property :parent headline))
                     (foo1 (org-element-property :title parent)))
                                              ;(and foo1 (message (format "Got %s" (substring-no-properties (car foo1)))))
                (and (eq (org-element-type parent) 'headline)
                     (string= (org-element-property :raw-value parent) "Projects")
                     (= (org-element-property :level parent) 1)
                     (org-element-property :raw-value headline)
                     )))))
        )
      
      
    #+end_src

*** Contacts
    From https://www.reddit.com/r/emacs/comments/8toivy/tip_how_to_manage_your_contacts_with_orgcontacts/:
    With
    #+begin_src emacs-lisp
      (use-package org-capture
        :ensure nil
        :demand
        :after org
        :preface
        (setq my/org-contacts-template "* %(org-contacts-template-name)
      :PROPERTIES:
      :ADDRESS: %^{14217 Tyler Rd, Valley Center, CA 92082, USA}
      :BIRTHDAY: %^{yyyy-mm-dd}
      :EMAIL: %(org-contacts-template-email)
      :NOTE: %^{NOTE}
      :END:")
        :config
        (add-to-list 'org-capture-templates
                     `("C" "Contact" entry (file+headline ssmm-org-contacts-file "Friends"),
                       my/org-contacts-template
                       :empty-lines 1))
      
        )
      
    #+end_src
*** Org-Mode Hook -- Keybindings
    :PROPERTIES:
    :CUSTOM_ID: keybindings
    :END:
    #+begin_src emacs-lisp
      (add-hook 'org-mode-hook
                (lambda ()
                  (local-set-key "\M-\C-n" 'outline-next-visible-heading)
                  (local-set-key "\M-\C-p" 'outline-previous-visible-heading)
                  (local-set-key "\M-\C-u" 'outline-up-heading)
                  ;; table
                  (local-set-key "\M-\C-w" 'org-table-copy-region)
                  (local-set-key "\M-\C-y" 'org-table-paste-rectangle)
                  (local-set-key "\M-\C-l" 'org-table-sort-lines)
                  ;; display images
                  (local-set-key "\M-I" 'org-toggle-inline-images)))
    #+end_src


*** Speed keys
    :PROPERTIES:
    :CUSTOM_ID: speed-keys
    :END:
    Speed commands enable single-letter commands in Org-mode files when
    the point is at the beginning of a headline, or at the beginning of a
    code block.

    See the `=org-speed-commands-default=' variable for a list of the keys
    and commands enabled at the beginning of headlines.  All code blocks
    are available at the beginning of a code block, the following key
    sequence =C-c C-v h= (bound to `=org-babel-describe-bindings=') will
    display a list of the code blocks commands and their related keys.

    To use, type "C-c C-," and then a letter per instructions in the buffer.

    #+begin_src emacs-lisp
      (setq org-use-speed-commands t)
      (add-to-list 'org-structure-template-alist '("S" . "src emacs-lisp"))
      (add-to-list 'org-structure-template-alist '("b" . "src sh"))
      (add-to-list 'org-structure-template-alist '("B" . "src sh ? :results output verbatim drawer "))
    #+end_src

*** Code blocks
    :PROPERTIES:
    :CUSTOM_ID: babel
    :END:
    This activates a number of widely used languages, you are encouraged
    to activate more languages using the customize interface for the
    `=org-babel-load-languages=' variable, or with an elisp form like the
    one below.  The customize interface of `=org-babel-load-languages='
    contains an up to date list of the currently supported languages.
    #+begin_src emacs-lisp
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
         (C . t)
         (plantuml . t)
         (python . t)
         (dot . t)
         (shell . t)
         (screen . t)
         ))
      (require 'ob-dot)
                                              ; Allow async OB operations
      (require 'ob-async)
    #+end_src

    You are encouraged to add the following to your personal configuration
    although it is not added by default as a security precaution.
    #+begin_src emacs-lisp
      (setq org-confirm-babel-evaluate nil)
    #+end_src

*** Code block fontification
    :PROPERTIES:
    :CUSTOM_ID: code-block-fontification
    :END:
    The following displays the contents of code blocks in Org-mode files
    using the major-mode of the code.  It also changes the behavior of
    =TAB= to as if it were used in the appropriate major mode.  This means
    that reading and editing code form inside of your Org-mode files is
    much more like reading and editing of code using its major mode.
    #+begin_src emacs-lisp
      (setq org-src-fontify-natively t)
      (setq org-src-tab-acts-natively t)
    #+end_src

*** The Library of Babel
    :PROPERTIES:
    :CUSTOM_ID: library-of-babel
    :END:
    The library of babel contains makes many useful functions available
    for use by code blocks in *any* emacs file.  See the actual
    =library-of-babel.org= (located in the Org-mode =contrib/babel=
    directory) file for information on the functions, and see
    [[http://orgmode.org/worg/org-contrib/babel/intro.php#library-of-babel][worg:library-of-babel]] for more usage information.

    Code blocks can be loaded into the library of babel from any Org-mode
    file using the `org-babel-lob-ingest' function.

** Compilation mode
   #+begin_src emacs-lisp
     (add-to-list 'compilation-error-regexp-alist-alist
                  '(flint
                    "<\\([^<>:]+\\):\\([0-9]+\\)>" 1 2))
     (add-to-list 'compilation-error-regexp-alist
                  'flint)
   #+end_src

** Ag
   #+begin_src emacs-lisp
     (use-package ag
       :commands ag
       )
   #+end_src

   #+begin_src emacs-lisp
     (use-package iedit
       :defer t
       )
   #+end_src

** C mode
   #+begin_src emacs-lisp
     (use-package cc-mode
       :preface
       (defun my-c-mode-hook ()
         (setq indent-tabs-mode nil)
         (c-set-style "std-style")
         (electric-indent-mode t)
         (setq whitespace-line-column 120)
         (setq whitespace-style '(face trailing lines space-before-tab indentation space-after-tab))
         (whitespace-mode t)
                                             ;(add-hook 'before-save-hook 'whitespace-cleanup) This is still getting into the makefile before-save-hook????
         )
     
       :hook (c-mode-common . my-c-mode-hook)
     
       :config
       (c-add-style "std-style"
                    '((c-basic-offset . 4)     ; Guessed value
                      (c-offsets-alist
                       (arglist-cont . 0)      ; Guessed value
                       (arglist-intro . +)     ; Guessed value
                       (block-close . 0)       ; Guessed value
                       (brace-list-close . 0)  ; Guessed value
                       (brace-list-entry . 0)  ; Guessed value
                       (brace-list-intro . +)  ; Guessed value
                       (brace-list-open . 0)   ; Guessed value
                       (case-label . +)        ; Guessed value
                       (class-close . 0)       ; Guessed value
                       (class-open . 0)        ; Guessed value
                       (defun-block-intro . +) ; Guessed value
                       (defun-close . 0)       ; Guessed value
                       (defun-open . 0)        ; Guessed value
                       (else-clause . 0)       ; Guessed value
                       (inclass . +)           ; Guessed value
                       (statement . 0)             ; Guessed value
                       (statement-block-intro . +) ; Guessed value
                       (statement-case-intro . +) ; Guessed value
                       (statement-cont . +)    ; Guessed value
                       (substatement . +)      ; Guessed value
                       (substatement-open . 0) ; Guessed value
                       (topmost-intro . 0)     ; Guessed value
                       (topmost-intro-cont . 0) ; Guessed value
                       (access-label . -)
                       (annotation-top-cont . 0)
                       (annotation-var-cont . +)
                       (arglist-close . c-lineup-close-paren)
                       (arglist-cont-nonempty . c-lineup-arglist)
                       (block-open . 0)
                       (brace-entry-open . 0)
                       (c . c-lineup-C-comments)
                       (catch-clause . 0)
                       (comment-intro . c-lineup-comment)
                       (composition-close . 0)
                       (composition-open . 0)
                       (cpp-define-intro c-lineup-cpp-define +)
                       (cpp-macro . -1000)
                       (cpp-macro-cont . +)
                       (do-while-closure . 0)
                       (extern-lang-close . 0)
                       (extern-lang-open . 0)
                       (friend . 0)
                       (func-decl-cont . +)
                       (incomposition . +)
                       (inexpr-class . +)
                       (inexpr-statement . +)
                       (inextern-lang . +)
                       (inher-cont . c-lineup-multi-inher)
                       (inher-intro . +)
                       (inlambda . c-lineup-inexpr-block)
                       (inline-close . 0)
                       (inline-open . +)
                       (inmodule . +)
                       (innamespace . +)
                       (knr-argdecl . 0)
                       (knr-argdecl-intro . +)
                       (label . +)
                       (lambda-intro-cont . +)
                       (member-init-cont . c-lineup-multi-inher)
                       (member-init-intro . +)
                       (module-close . 0)
                       (module-open . 0)
                       (namespace-close . 0)
                       (namespace-open . 0)
                       (objc-method-args-cont . c-lineup-ObjC-method-args)
                       (objc-method-call-cont c-lineup-ObjC-method-call-colons c-lineup-ObjC-method-call +)
                       (objc-method-intro .
                                          [0])
                       (statement-case-open . 0)
                       (stream-op . c-lineup-streamop)
                       (string . -1000)
                       (substatement-label . +)
                       (template-args-cont c-lineup-template-args +))))
     
     
       )
   #+end_src

** Make modes
   #+begin_src emacs-lisp
     (use-package make-mode
       :preface
       (defun my-makefile-mode-hook()
         (remove-hook 'before-save-hook 'whitespace-cleanup)
         )
       :hook ((makefile-mode makefile-gmake-mode) . my-makefile-mode-hook)
       :mode ("\\.mak$" . makefile-gmake-mode)
       )
   #+end_src

** Perl mode
   #+begin_src emacs-lisp
     (use-package cperl-mode
       :preface
       (defun my-perl-mode-hooks ()
         (setq cperl-indent-level 2)
         ;; (setq cperl-continued-statement-offset 0)
         (cperl-set-style "C++")
         ;; (setq cperl-auto-newline t)
         (setq font-lock-maximum-decoration 1)
         (set-face-foreground 'cperl-hash-face "sandy brown")
         (set-face-foreground 'cperl-array-face "olive drab")
         ;;RSF: Find ssmm-cleanup-buffer... (add-hook 'before-save-hook 'ssmm-cleanup-buffer)
         )
     
       :hook (cperl-mode . my-perl-mode-hooks)
     
       :bind (("C-h P" . perldoc)
              :map cperl-mode-map
              ("RET" . reindent-then-newline-and-indent)
              ("C-M-h" . backward-kill-word)
              )
     
       :mode
       (("\\.p[lm]$" . cperl-mode)
        ("\\.pod$" . pod-mode)
        ("\\.tt$" . tt-mode))
     
       )
   #+end_src
** Python mode
   #+begin_src emacs-lisp
     (use-package sphinx-doc
       :defer t)
     
     (use-package python-mode
       ;;(add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
       ;;(add-to-list 'interpreter-mode-alist '("python" . python-mode))
       :preface
     
       (defun my-python-mode-hook ()
         (setq indent-tabs-mode nil)
         (setq py-indent-offset 4)
         (setq whitespace-style '(face trailing lines space-before-tab indentation space-after-tab))
         (whitespace-mode t)
         (pyenv-mode)
         )
     
       :hook (python-mode (my-python-mode-hook . blacken-mode))
       ;; make sure we have lsp-imenu everywhere we have LSP
                                             ;  (require 'lsp-imenu)
                                             ;  (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)
       ;; get lsp-python-enable defined
       ;; NB: use either projectile-project-root or ffip-get-project-root-directory
       ;;     or any other function that can be used to find the root directory of a project
                                             ;  (lsp-define-stdio-client lsp-python "python"
                                             ;                           #'projectile-project-root
                                             ;                           '("pyls"))
     
       ;; make sure this is activated when python-mode is activated
       ;; lsp-python-enable is created by macro above
                                             ;  (add-hook 'python-mode-hook
                                             ;            (lambda ()
                                             ;              (lsp-python-enable)))
       :after sphinx-doc
       )
     
     (use-package elpy
       :ensure t
       :init
       (advice-add 'python-mode :before 'elpy-enable)
       ;; (add-hook 'python-mode-hook 'jedi:setup)
       ;; (setq jedi:complete-on-dot t) ; optional
       :config
       (setq elpy-rpc-python-command "/usr/bin/python3")
       (put 'pyvenv-activate 'safe-local-variable #'stringp)
       )
   #+end_src

   #+begin_src emacs-lisp
     ;; (use-package pyvenv
     ;; :defer t
     ;; :config
     ;;   (add-hook 'pyvenv-post-activate-hooks 'pyvenv-restart-python)
     ;; )
   #+end_src
   #+begin_src emacs-lisp
                                             ;    (with-package elpy
                                             ;   (elpy-enable)
                                             ;      )
   #+end_src

** Mastodon
   #+begin_src emacs-lisp
     (when (not (version< emacs-version "27.1"))
       (use-package mastodon
         :ensure t
         :config
         (setq mastodon-instance-url "https://emacs.ch"
               mastodon-active-user "sesamemucho")
         ))
   #+end_src
** Yaml
   #+begin_src emacs-lisp
     (use-package yaml-mode
       :mode
       ("\\.yml$" . yaml-mode)
       )
   #+end_src

** Snippets
   #+begin_src emacs-lisp
     (use-package yasnippet
       :ensure t
       :config
       (yas-global-mode)
                                             ;(add-to-list 'yas/root-directory "~/.emacs.d/snippets")
                                             ;(add-to-list 'yas/root-directory "~/.emacs.d/elpa-snippets")
       (setq yas-root-directory "~/.emacs.d/snippets")
       (yas-load-directory yas-root-directory)
       )
   #+end_src
** Projectile
   #+begin_src emacs-lisp
     (use-package projectile
       :init
       (projectile-mode +1)
       (add-to-list 'projectile-project-root-files ".gitignore")
       (add-to-list 'projectile-project-root-files "PBC.xml")
       :bind (:map projectile-mode-map
                   ("s-p" . projectile-command-map)
                   ("C-c p" . projectile-command-map)))
   #+end_src
** undo-tree
   #+begin_src emacs-lisp
     (use-package undo-tree
       :defer t
       :config
       (global-undo-tree-mode 1)
       )
   #+end_src

** Counsel
   #+begin_src emacs-lisp
     (use-package counsel
       :after ivy
       :demand t
       :diminish
       :custom (counsel-find-file-ignore-regexp
                (concat "\\(\\`\\.[^.]\\|"
                        (regexp-opt completion-ignored-extensions)
                        "\\'\\)"))
       :bind (("C-*"     . counsel-org-agenda-headlines)
              ("C-x C-f" . counsel-find-file)
              ("C-c e l" . counsel-find-library)
              ("C-c e q" . counsel-set-variable)
              ("C-h e l" . counsel-find-library)
              ("C-h e u" . counsel-unicode-char)
              ("C-h f"   . counsel-describe-function)
              ("C-x r b" . counsel-bookmark)
              ("M-x"     . counsel-M-x)
              ;; ("C-s"     . swiper-isearch)
              ;; ("M-y"     . counsel-yank-pop)
     
              ("M-s f" . counsel-file-jump)
              ;; ("M-s g" . counsel-rg)
              ("M-s j" . counsel-dired-jump))
       :commands counsel-minibuffer-history
       :init
       (bind-key "M-r" #'counsel-minibuffer-history minibuffer-local-map)
       :config
       (add-to-list 'ivy-sort-matches-functions-alist
                    '(counsel-find-file . ivy--sort-files-by-date))
     
       (use-package counsel-projectile
         :after (counsel projectile)
         :config
         (counsel-projectile-mode 1))
     
       (use-package counsel-tramp
         :commands counsel-tramp)
     
   #+end_src

** Ivy
   #+begin_src emacs-lisp
     (use-package ivy
       :diminish
       :demand t
     
       :bind (("C-x b" . ivy-switch-buffer)
              ("C-x B" . ivy-switch-buffer-other-window)
              ("M-H"   . ivy-resume))
     
       :bind (:map ivy-minibuffer-map
                   ("<tab>" . ivy-alt-done)
                   ("SPC"   . ivy-alt-done-or-space)
                   ("C-d"   . ivy-done-or-delete-char)
                   ("M-i"   . ivy-partial)
                   ("C-i"   . ivy-partial-or-done)
                   ("C-r"   . ivy-previous-line-or-history)
                   ("M-r"   . ivy-reverse-i-search))
     
       :bind (:map ivy-switch-buffer-map
                   ("C-k" . ivy-switch-buffer-kill))
     
       :custom
       (ivy-dynamic-exhibit-delay-ms 200)
       (ivy-height 10)
       (ivy-initial-inputs-alist nil t)
       (ivy-magic-tilde nil)
       (ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
       (ivy-use-virtual-buffers t)
       (ivy-tab-space t)
       (ivy-wrap t)
     
       :preface
       (defun ivy-done-or-delete-char ()
         (interactive)
         (call-interactively
          (if (eolp)
              #'ivy-immediate-done
            #'ivy-delete-char)))
     
       (defun ivy-alt-done-or-space ()
         (interactive)
         (call-interactively
          (if (= ivy--length 1)
              #'ivy-alt-done
            #'self-insert-command)))
     
       (defun ivy-switch-buffer-kill ()
         (interactive)
         (debug)
         (let ((bn (ivy-state-current ivy-last)))
           (when (get-buffer bn)
             (kill-buffer bn))
           (unless (buffer-live-p (ivy-state-buffer ivy-last))
             (setf (ivy-state-buffer ivy-last)
                   (with-ivy-window (current-buffer))))
           (setq ivy--all-candidates (delete bn ivy--all-candidates))
           (ivy--exhibit)))
     
       ;; This is the value of `magit-completing-read-function', so that we see
       ;; Magit's own sorting choices.
       (defun my-ivy-completing-read (&rest args)
         (let ((ivy-sort-functions-alist '((t . nil))))
           (apply 'ivy-completing-read args)))
     
       :config
       (ivy-mode 1)
       (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur)))
     
     (use-package ivy-hydra
       :after (ivy hydra)
       :defer t)
     
   #+end_src

** Magit, etc.
   #+begin_src emacs-lisp
     (use-package magit
       :bind ("C-x g" . magit-status)
       )
   #+end_src

** Key chord
   #+begin_src emacs-lisp
     (use-package key-chord
       :defer t
       :config
       (key-chord-mode 1)
     
                                             ;(key-chord-define-global "hj" 'ace-jump-line-mode)
                                             ;(key-chord-define-global "jk" 'ace-jump-mode)
       (key-chord-define-global "hj" 'avy-goto-word-or-subword-1)
       (key-chord-define-global "jk" 'ace-window)
       (key-chord-define-global "ji" (lambda () (interactive) (backward-char) (next-line)))
       (key-chord-define-global "JI" (lambda () (interactive) (backward-char) (next-line)))
                                             ;(key-chord-define-global "fj" 'ido-find-file)
                                             ;(key-chord-define-global "fk" 'ido-find-file-other-window)
       )
   #+end_src

** LSP
   #+begin_src emacs-lisp
     ;; (use-package company-lsp
     ;;   :after lsp-mode
     ;;   :config
     ;;   (require 'lsp-clients)
     ;;   (push 'company-lsp company-backends))
     
     ;; (use-package lsp-mode
     ;;   :commands lsp)
     
     ;; (use-package lsp-ui
     ;;   :hook (lsp-mode . lsp-ui-mode)
     ;;   :config
     ;;   (define-key lsp-ui-mode-map [remap xref-find-definitions]
     ;;     #'lsp-ui-peek-find-definitions)
     ;;   (define-key lsp-ui-mode-map [remap xref-find-references]
     ;;     #'lsp-ui-peek-find-references))
     
   #+end_src

** Load user files
   When you want to make an sk-load to load prelude stuff at the
   beginning of this file:
   (cl-delete-if (lambda (f) (string-match-p "prelude"f)) foo)
   So, load files that have "prelude" in there names there, and don't
   load them here.
   Come to think about it, it would probably be OK to load them here
   also.
   #+begin_src emacs-lisp
     (cl-flet ((sk-load (base)
                        (let* ((path          (expand-file-name base ssmm/cfg-dir))
                               (literate      (concat path ".org"))
                               (encrypted-org (concat path ".org.gpg"))
                               (plain         (concat path ".el"))
                               (encrypted-el  (concat path ".el.gpg")))
                          (cond
                           ((file-exists-p encrypted-org) (org-babel-load-file encrypted-org))
                           ((file-exists-p encrypted-el)  (load encrypted-el))
                           ((file-exists-p literate)      (org-babel-load-file literate))
                           ((file-exists-p plain)         (load plain)))))
               (remove-extension (name)
                                 (string-match "\\(.*?\\)\.\\(org\\(\\.el\\)?\\|el\\)\\(\\.gpg\\)?$" name)
                                 (match-string 1 name)))
       (let ((elisp-dir (expand-file-name "src" ssmm/cfg-dir))
             (user-dir (expand-file-name user-login-name ssmm/cfg-dir))
             (user-local-dir (expand-file-name "~/.emacs-local"))
             )
         ;; add the src directory to the load path
         (add-to-list 'load-path elisp-dir)
         ;; load specific files
         (when (file-exists-p elisp-dir)
           (let ((default-directory elisp-dir))
             (normal-top-level-add-subdirs-to-load-path)))
         ;; load system-specific config
         (sk-load (system-name))
         ;; load user-specific config
         (sk-load user-login-name)
         ;; load any files in the user's directory
         (when (file-exists-p user-dir)
           (add-to-list 'load-path user-dir)
           (mapc #'sk-load
                 (cl-remove-duplicates
                  (mapcar #'remove-extension
                          (directory-files user-dir t ".*\.\\(org\\|el\\)\\(\\.gpg\\)?$"))
                  :test #'string=)))
         (when (file-exists-p user-local-dir)
           (add-to-list 'load-path user-local-dir)
           (mapc #'sk-load
                 (cl-remove-duplicates
                  (mapcar #'remove-extension
                          (directory-files user-local-dir t ".*\.\\(org\\|el\\)\\(\\.gpg\\)?$"))
                  :test #'string=)))
         ))
   #+end_src

   - Compile bare elisp files
     #+begin_src emacs-lisp
       (byte-recompile-directory (concat ssmm/cfg-dir "lisp/") 0)
       ;;(byte-recompile-directory "~/.emacs.d/etc/" 0)
     #+end_src

** Last words
   This is the last section to be run during startup.

   #+begin_src emacs-lisp
     
     (server-start)
     (require 'ivy)
     (require 'counsel)
     
   #+end_src
